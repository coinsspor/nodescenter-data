# 4. Restart services if needed\nsudo systemctl restart story story-geth\n\n# 5. Monitor restart\necho \"üîÑ Monitoring restart...\"\nsudo journalctl -u story -u story-geth -f --since \"1 minute ago\"\n```\n\n**Advanced Sync Troubleshooting:**\n\n```bash\n# Check state sync configuration\ngrep -A 5 \"\\[statesync\\]\" $HOME/.story/story/config/config.toml\n\n# Disable state sync if causing issues\nsed -i 's/enable = true/enable = false/' $HOME/.story/story/config/config.toml\n\n# Clear address book and restart\nmv $HOME/.story/story/config/addrbook.json $HOME/.story/story/config/addrbook.json.backup\nsudo systemctl restart story\n```\n\n## üíæ Disk Space Issues\n\n### Symptoms\n- Services crashing due to disk space\n- `No space left on device` errors\n- Node stops syncing\n\n### Solutions\n\n```bash\n# 1. Check disk usage\ndf -h\ndu -sh $HOME/.story/*\n\n# 2. Clean old logs\nsudo journalctl --vacuum-time=3d\nsudo journalctl --vacuum-size=1G\n\n# 3. Check for large log files\nfind $HOME/.story -name \"*.log\" -size +100M -exec ls -lh {} \\;\n\n# 4. Clean temporary files\nrm -rf /tmp/coinsspor_sync\nrm -rf /tmp/story_*\n\n# 5. Prune old snapshots (if any)\nfind $HOME -name \"*.tar.zst\" -mtime +7 -delete\n```\n\n**Emergency Disk Space Recovery:**\n\n```bash\n# If critically low on space, use snapshot to resync\necho \"üö® Emergency disk recovery - using snapshot\"\n\n# Stop services\nsudo systemctl stop story story-geth\n\n# Remove data directories\nrm -rf $HOME/.story/story/data\nrm -rf $HOME/.story/geth/aeneid/geth/chaindata\n\n# Use Coinsspor snapshot (see snapshot section)\n# This will restore ~200GB+ of space\n```\n\n## üîå Port Conflicts\n\n### Symptoms\n- Services fail to start\n- `Address already in use` errors\n- Cannot bind to port\n\n### Solutions\n\n```bash\n# 1. Check what's using your ports\necho \"üîç Checking port usage...\"\nfor port in \"${STORY_PORT}657\" \"${STORY_PORT}656\" \"${STORY_PORT}545\" \"${STORY_PORT}303\"; do\n    echo \"Port $port:\"\n    sudo netstat -tulpn | grep \":$port \"\ndone\n\n# 2. Kill conflicting processes\necho \"üîß Killing conflicting processes...\"\nsudo lsof -ti:${STORY_PORT}657 | xargs sudo kill -9 2>/dev/null\nsudo lsof -ti:${STORY_PORT}656 | xargs sudo kill -9 2>/dev/null\nsudo lsof -ti:${STORY_PORT}545 | xargs sudo kill -9 2>/dev/null\n\n# 3. Change port prefix if conflicts persist\necho \"‚öôÔ∏è Changing port prefix to avoid conflicts...\"\nread -p \"Enter new port prefix (e.g., 56, 66, 76): \" NEW_PORT\n\nif [[ \"$NEW_PORT\" =~ ^[0-9]+$ ]] && [ \"$NEW_PORT\" -ge 10 ] && [ \"$NEW_PORT\" -le 99 ]; then\n    echo \"export STORY_PORT=\\\"$NEW_PORT\\\"\" >> $HOME/.bash_profile\n    source $HOME/.bash_profile\n    \n    # Reconfigure ports\n    sed -i.bak -e \"s%:${NEW_PORT}[0-9][0-9][0-9]%:${NEW_PORT}657%g\" $HOME/.story/story/config/config.toml\n    # Update service files and restart\n    echo \"‚úÖ Port prefix changed to $NEW_PORT\"\nelse\n    echo \"‚ùå Invalid port prefix\"\nfi\n```\n\n## üö´ Service Won't Start\n\n### Symptoms\n- `systemctl start` fails\n- Service shows `failed` status\n- Immediate crashes\n\n### Solutions\n\n```bash\n# 1. Check service status and logs\nsudo systemctl status story story-geth\nsudo journalctl -u story -n 50 --no-pager\nsudo journalctl -u story-geth -n 50 --no-pager\n\n# 2. Check binary permissions and existence\necho \"üìÅ Checking binaries...\"\nls -la $HOME/go/bin/story*\nls -la $HOME/go/bin/cosmovisor\n\n# Fix permissions if needed\nchmod +x $HOME/go/bin/story\nchmod +x $HOME/go/bin/story-geth\nchmod +x $HOME/go/bin/cosmovisor\n\n# 3. Verify environment variables\necho \"üåê Environment check:\"\necho \"DAEMON_HOME: $DAEMON_HOME\"\necho \"DAEMON_NAME: $DAEMON_NAME\"\necho \"STORY_PORT: $STORY_PORT\"\n\n# 4. Test binary manually\necho \"üß™ Testing binaries...\"\n$HOME/go/bin/story version\n$HOME/go/bin/story-geth version\n$HOME/go/bin/cosmovisor version\n\n# 5. Check file system permissions\nsudo chown -R $USER:$USER $HOME/.story\nsudo chown $USER:$USER $HOME/go/bin/*\n```\n\n**Service Recovery Script:**\n\n```bash\n# Create comprehensive service recovery\ncat > $HOME/service_recovery.sh << 'EOF'\n#!/bin/bash\n\necho \"üõ†Ô∏è Service Recovery Assistant\"\necho \"=============================\"\n\n# Stop all processes\necho \"üõë Stopping all processes...\"\nsudo systemctl stop story story-geth\nsudo pkill -f \"story\"\nsudo pkill -f \"geth\"\nsudo pkill -f \"cosmovisor\"\nsleep 5\n\n# Check for remaining processes\necho \"üîç Checking for remaining processes...\"\nps aux | grep -E \"(story|geth|cosmovisor)\" | grep -v grep\n\n# Verify critical files\necho \"üìÅ Verifying critical files...\"\nCRITICAL_FILES=(\n    \"$HOME/go/bin/story\"\n    \"$HOME/go/bin/story-geth\"\n    \"$HOME/go/bin/cosmovisor\"\n    \"$HOME/.story/story/config/config.toml\"\n    \"$HOME/.story/story/config/genesis.json\"\n)\n\nfor file in \"${CRITICAL_FILES[@]}\"; do\n    if [ -f \"$file\" ]; then\n        echo \"‚úÖ $file exists\"\n    else\n        echo \"‚ùå $file missing!\"\n    fi\ndone\n\n# Reset systemd\necho \"üîÑ Resetting systemd...\"\nsudo systemctl daemon-reload\nsudo systemctl reset-failed story story-geth\n\n# Restart services\necho \"üöÄ Starting services...\"\nsudo systemctl start story-geth\necho \"‚è≥ Waiting 15 seconds for Story-Geth...\"\nsleep 15\n\nsudo systemctl start story\necho \"‚è≥ Waiting 10 seconds for Story...\"\nsleep 10\n\n# Verify recovery\necho \"üìä Recovery Status:\"\nsudo systemctl is-active story && echo \"‚úÖ Story: Active\" || echo \"‚ùå Story: Failed\"\nsudo systemctl is-active story-geth && echo \"‚úÖ Story-Geth: Active\" || echo \"‚ùå Story-Geth: Failed\"\n\necho \"=============================\"\nEOF\n\nchmod +x $HOME/service_recovery.sh\n```\n\n## üîÑ Cosmovisor Issues\n\n### Symptoms\n- Upgrades not working\n- Binary not found errors\n- Version mismatches\n\n### Solutions\n\n```bash\n# 1. Check cosmovisor setup\ncosmovisor version\nls -la $DAEMON_HOME/cosmovisor/\n\n# 2. Verify current binary\nls -la $DAEMON_HOME/cosmovisor/current/bin/\nreadlink $DAEMON_HOME/cosmovisor/current\n\n# 3. Check upgrade directory\nls -la $DAEMON_HOME/cosmovisor/upgrades/\n\n# 4. Reset to genesis binary if corrupted\necho \"üîÑ Resetting cosmovisor to genesis binary...\"\nrm -f $DAEMON_HOME/cosmovisor/current\nln -s $DAEMON_HOME/cosmovisor/genesis $DAEMON_HOME/cosmovisor/current\n\n# 5. Reinitialize cosmovisor\ncosmovisor init $(which story)\n\n# 6. Check environment variables\necho \"üåê Cosmovisor environment:\"\nenv | grep DAEMON\n```\n\n**Cosmovisor Complete Reset:**\n\n```bash\n# Complete cosmovisor reset (emergency)\necho \"üö® Complete Cosmovisor Reset\"\necho \"============================\"\n\n# Stop story service\nsudo systemctl stop story\n\n# Backup current setup\nmv $DAEMON_HOME/cosmovisor $DAEMON_HOME/cosmovisor.backup.$(date +%Y%m%d_%H%M%S)\n\n# Reinitialize completely\ncosmovisor init $(which story)\n\n# Restore environment\nsource $HOME/.bash_profile\n\n# Restart service\nsudo systemctl start story\n\necho \"‚úÖ Cosmovisor reset complete\"\n```\n\n## ‚ö†Ô∏è Validator Issues\n\n### Symptoms\n- Not signing blocks\n- Validator offline\n- Missing attestations\n\n### Solutions\n\n```bash\n# 1. Check validator status\ncurl localhost:${STORY_PORT}657/status | jq '.result.validator_info'\n\n# 2. Verify validator key exists and is correct\necho \"üîë Checking validator key...\"\nif [ -f \"$HOME/.story/story/config/priv_validator_key.json\" ]; then\n    echo \"‚úÖ Validator key exists\"\n    # Check key format\n    jq empty $HOME/.story/story/config/priv_validator_key.json && echo \"‚úÖ Valid JSON\" || echo \"‚ùå Corrupted JSON\"\nelse\n    echo \"‚ùå Validator key missing!\"\n    echo \"üö® CRITICAL: Restore from backup immediately!\"\nfi\n\n# 3. Check if node is synced\nCATCHING_UP=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.catching_up')\nif [ \"$CATCHING_UP\" = \"false\" ]; then\n    echo \"‚úÖ Node is synced\"\nelse\n    echo \"‚ö†Ô∏è Node is still syncing - validator won't sign until synced\"\nfi\n\n# 4. Check validator in validator set\nVALIDATOR_ADDR=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.validator_info.address')\nif [ \"$VALIDATOR_ADDR\" != \"null\" ] && [ -n \"$VALIDATOR_ADDR\" ]; then\n    echo \"üìç Validator address: $VALIDATOR_ADDR\"\n    curl localhost:${STORY_PORT}657/validators | jq --arg addr \"$VALIDATOR_ADDR\" '.result.validators[] | select(.address==$addr)'\nelse\n    echo \"‚ùå Not running as validator\"\nfi\n\n# 5. Monitor validator performance\necho \"üìä Checking recent block signing...\"\nLATEST_HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\nSIGNED_COUNT=0\n\nfor i in {1..10}; do\n    HEIGHT=$((LATEST_HEIGHT - i))\n    BLOCK=$(curl -s localhost:${STORY_PORT}657/block?height=$HEIGHT)\n    if echo \"$BLOCK\" | jq -r '.result.block.last_commit.signatures[].validator_address' | grep -q \"$VALIDATOR_ADDR\"; then\n        SIGNED_COUNT=$((SIGNED_COUNT + 1))\n    fi\ndone\n\necho \"üìà Signed $SIGNED_COUNT out of last 10 blocks\"\n```\n\n## üåê Network Connectivity Issues\n\n### Solutions\n\n```bash\n# Network diagnostic script\ncat > $HOME/network_diagnostics.sh << 'EOF'\n#!/bin/bash\n\necho \"üåê Network Diagnostics\"\necho \"=====================\"\n\n# Test DNS resolution\necho \"üîç DNS Resolution:\"\nnslookup aeneid.storyrpc.io >/dev/null && echo \"‚úÖ DNS working\" || echo \"‚ùå DNS issues\"\n\n# Test internet connectivity\necho \"\\nüåç Internet Connectivity:\"\nping -c 3 8.8.8.8 >/dev/null && echo \"‚úÖ Internet accessible\" || echo \"‚ùå No internet access\"\n\n# Test RPC endpoints\necho \"\\nüì° RPC Endpoint Tests:\"\nRPC_ENDPOINTS=(\n    \"https://aeneid.storyrpc.io/status\"\n    \"https://story-aeneid-testnet-rpc.coinsspor.com/status\"\n)\n\nfor endpoint in \"${RPC_ENDPOINTS[@]}\"; do\n    echo -n \"Testing $endpoint: \"\n    if curl -s --max-time 10 \"$endpoint\" >/dev/null; then\n        echo \"‚úÖ OK\"\n    else\n        echo \"‚ùå Failed\"\n    fi\ndone\n\n# Test local services\necho \"\\nüè† Local Service Tests:\"\nLOCAL_ENDPOINTS=(\n    \"localhost:${STORY_PORT}657/status\"\n    \"localhost:${STORY_PORT}545\"\n)\n\nfor endpoint in \"${LOCAL_ENDPOINTS[@]}\"; do\n    echo -n \"Testing $endpoint: \"\n    if curl -s --max-time 5 \"$endpoint\" >/dev/null; then\n        echo \"‚úÖ OK\"\n    else\n        echo \"‚ùå Failed\"\n    fi\ndone\n\n# Check firewall status\necho \"\\nüî• Firewall Status:\"\nif command -v ufw >/dev/null; then\n    sudo ufw status | head -5\nelse\n    echo \"UFW not installed\"\nfi\n\n# Check peer connectivity\necho \"\\nüë• Peer Connectivity:\"\nPEER_COUNT=$(curl -s localhost:${STORY_PORT}657/net_info | jq -r '.result.n_peers' 2>/dev/null || echo \"0\")\necho \"Connected peers: $PEER_COUNT\"\n\nif [ \"$PEER_COUNT\" -lt 5 ]; then\n    echo \"‚ö†Ô∏è Low peer count - may need fresh peers\"\nfi\n\necho \"====================\"\nEOF\n\nchmod +x $HOME/network_diagnostics.sh\n./network_diagnostics.sh\n```"
        },
        {
          "id": "emergency-procedures",
          "title": "Emergency Procedures",
          "icon": "üÜò",
          "type": "page",
          "content": "# üÜò Emergency Procedures\n\nCritical emergency procedures for when your validator is in immediate danger or experiencing severe issues.\n\n## üö® Validator Emergency Recovery\n\n### When to Use\n- Validator is offline and losing uptime\n- Critical errors preventing node operation\n- Hardware failures\n- Severe sync issues\n\n```bash\n# Emergency validator recovery script\ncat > $HOME/emergency_validator_recovery.sh << 'EOF'\n#!/bin/bash\n\necho \"üö® EMERGENCY VALIDATOR RECOVERY\"\necho \"===============================\"\necho \"‚ö†Ô∏è  This is for EMERGENCY situations only!\"\necho \"‚ö†Ô∏è  Use only if validator is offline and at risk!\"\necho \"\"\nread -p \"Continue with emergency recovery? (y/N): \" confirm\n\nif [ \"$confirm\" != \"y\" ] && [ \"$confirm\" != \"Y\" ]; then\n    echo \"Emergency recovery cancelled\"\n    exit 0\nfi\n\necho \"üîß Starting emergency recovery...\"\n\n# Step 1: Check if validator keys exist\necho \"üìã Step 1: Checking validator keys...\"\nif [ ! -f \"$HOME/.story/story/config/priv_validator_key.json\" ]; then\n    echo \"‚ùå CRITICAL: Validator key not found!\"\n    echo \"üö® You must restore from backup immediately!\"\n    echo \"   1. Locate your backup: priv_validator_key.json\"\n    echo \"   2. Copy to: $HOME/.story/story/config/\"\n    echo \"   3. Run this script again\"\n    exit 1\nelse\n    echo \"‚úÖ Validator key found\"\nfi\n\n# Step 2: Emergency service restart\necho \"\\nüìã Step 2: Emergency service restart...\"\nsudo systemctl stop story story-geth\nsudo pkill -f story\nsudo pkill -f geth\nsudo pkill -f cosmovisor\nsleep 10\n\n# Clear any locks\nrm -f $HOME/.story/story/data/cs.wal/wal\nrm -f $HOME/.story/geth/aeneid/geth/LOCK\n\n# Restart services\nsudo systemctl start story-geth\necho \"‚è≥ Waiting 20 seconds for Story-Geth...\"\nsleep 20\n\nsudo systemctl start story\necho \"‚è≥ Waiting 15 seconds for Story...\"\nsleep 15\n\n# Step 3: Verify recovery\necho \"\\nüìã Step 3: Verifying recovery...\"\nfor i in {1..30}; do\n    echo -n \"Attempt $i/30: \"\n    \n    if curl -s --max-time 5 localhost:${STORY_PORT}657/status >/dev/null 2>&1; then\n        HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\n        CATCHING_UP=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.catching_up')\n        \n        echo \"Height: $HEIGHT, Catching up: $CATCHING_UP\"\n        \n        if [ \"$CATCHING_UP\" = \"false\" ]; then\n            echo \"‚úÖ RECOVERY SUCCESSFUL - Node is synced!\"\n            break\n        fi\n    else\n        echo \"‚ùå Node not responding\"\n    fi\n    \n    sleep 10\ndone\n\n# Step 4: Final status check\necho \"\\nüìã Step 4: Final status check...\"\nVALIDATOR_STATUS=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.validator_info')\nif echo \"$VALIDATOR_STATUS\" | jq -e '.address' >/dev/null 2>&1; then\n    VALIDATOR_ADDR=$(echo \"$VALIDATOR_STATUS\" | jq -r '.address')\n    echo \"‚úÖ Validator active: $VALIDATOR_ADDR\"\nelse\n    echo \"‚ö†Ô∏è  Validator status unclear - check manually\"\nfi\n\necho \"\\n===============================\"\necho \"üÜò Emergency recovery completed\"\necho \"üìä Monitor status: sudo journalctl -u story -f\"\necho \"===============================\"\nEOF\n\nchmod +x $HOME/emergency_validator_recovery.sh\n```\n\n## üî• Critical File Recovery\n\n### Validator Key Recovery\n\n```bash\n# If validator key is corrupted or missing\necho \"üîë Validator Key Recovery\"\necho \"========================\"\n\n# Check if backup exists\nif [ -f \"$HOME/validator_backup/priv_validator_key.json\" ]; then\n    echo \"‚úÖ Backup found\"\n    \n    # Verify backup integrity\n    if jq empty \"$HOME/validator_backup/priv_validator_key.json\" 2>/dev/null; then\n        echo \"‚úÖ Backup is valid JSON\"\n        \n        # Stop services\n        sudo systemctl stop story\n        \n        # Restore key\n        cp \"$HOME/validator_backup/priv_validator_key.json\" \"$HOME/.story/story/config/\"\n        chmod 600 \"$HOME/.story/story/config/priv_validator_key.json\"\n        \n        # Restart services\n        sudo systemctl start story\n        \n        echo \"‚úÖ Validator key restored\"\n    else\n        echo \"‚ùå Backup is corrupted\"\n    fi\nelse\n    echo \"‚ùå No backup found!\"\n    echo \"üö® Check these locations:\"\n    echo \"   - $HOME/validator_backup/\"\n    echo \"   - External backup drives\"\n    echo \"   - Cloud backups\"\nfi\n```\n\n### Node Key Recovery\n\n```bash\n# Restore node identity if needed\necho \"üåê Node Key Recovery\"\necho \"==================\"\n\nif [ -f \"$HOME/validator_backup/node_key.json\" ]; then\n    sudo systemctl stop story\n    cp \"$HOME/validator_backup/node_key.json\" \"$HOME/.story/story/config/\"\n    chmod 600 \"$HOME/.story/story/config/node_key.json\"\n    sudo systemctl start story\n    echo \"‚úÖ Node key restored\"\nelse\n    echo \"‚ÑπÔ∏è  No node key backup - will generate new node ID\"\nfi\n```\n\n## üíæ Emergency Data Recovery\n\n### Snapshot Emergency Recovery\n\n```bash\n# Emergency data recovery using snapshots\ncat > $HOME/emergency_snapshot_recovery.sh << 'EOF'\n#!/bin/bash\n\necho \"üíæ Emergency Snapshot Recovery\"\necho \"==============================\"\necho \"‚ö†Ô∏è  This will replace ALL blockchain data!\"\necho \"‚ö†Ô∏è  Only use if data is corrupted!\"\necho \"\"\nread -p \"Continue with emergency snapshot recovery? (y/N): \" confirm\n\nif [ \"$confirm\" != \"y\" ] && [ \"$confirm\" != \"Y\" ]; then\n    echo \"Recovery cancelled\"\n    exit 0\nfi\n\n# Backup validator state\necho \"üíæ Backing up validator state...\"\nmkdir -p /tmp/emergency_backup\ncp $HOME/.story/story/config/priv_validator_key.json /tmp/emergency_backup/ 2>/dev/null\ncp $HOME/.story/story/data/priv_validator_state.json /tmp/emergency_backup/ 2>/dev/null\n\n# Stop services\necho \"üõë Stopping services...\"\nsudo systemctl stop story story-geth\n\n# Remove corrupted data\necho \"üßπ Removing corrupted data...\"\nrm -rf $HOME/.story/story/data\nrm -rf $HOME/.story/geth/aeneid/geth/chaindata\n\n# Download and apply snapshot (simplified version)\necho \"üì• Applying emergency snapshot...\"\necho \"This may take 10-30 minutes depending on connection...\"\n\n# Use Coinsspor snapshot service\nSNAPSHOT_BASE=\"https://snaps.coinsspor.com/story/aeneid\"\nMETADATA=$(curl -s \"$SNAPSHOT_BASE/coinsspor-info.json\")\nCONSENSUS_FILE=$(echo \"$METADATA\" | jq -r '.snapshots.consensus')\nEXECUTION_FILE=$(echo \"$METADATA\" | jq -r '.snapshots.execution')\n\nif [ \"$CONSENSUS_FILE\" != \"null\" ] && [ \"$EXECUTION_FILE\" != \"null\" ]; then\n    # Download and extract (basic version)\n    wget -q \"$SNAPSHOT_BASE/$CONSENSUS_FILE\" -O /tmp/consensus.tar.zst\n    wget -q \"$SNAPSHOT_BASE/$EXECUTION_FILE\" -O /tmp/execution.tar.zst\n    \n    # Extract\n    mkdir -p $HOME/.story/story/data\n    mkdir -p $HOME/.story/geth/aeneid/geth\n    \n    zstd -d /tmp/consensus.tar.zst -o /tmp/consensus.tar\n    zstd -d /tmp/execution.tar.zst -o /tmp/execution.tar\n    \n    tar -xf /tmp/consensus.tar -C $HOME/.story/story/\n    tar -xf /tmp/execution.tar -C $HOME/.story/geth/aeneid/geth/\n    \n    # Cleanup\n    rm -f /tmp/consensus.tar* /tmp/execution.tar*\n    \n    echo \"‚úÖ Snapshot applied\"\nelse\n    echo \"‚ùå Could not fetch snapshot metadata\"\n    exit 1\nfi\n\n# Restore validator state\necho \"üîÑ Restoring validator state...\"\ncp /tmp/emergency_backup/priv_validator_key.json $HOME/.story/story/config/ 2>/dev/null\ncp /tmp/emergency_backup/priv_validator_state.json $HOME/.story/story/data/ 2>/dev/null\n\n# Start services\necho \"üöÄ Starting services...\"\nsudo systemctl start story-geth\nsleep 15\nsudo systemctl start story\n\necho \"==============================\"\necho \"üíæ Emergency recovery completed\"\necho \"üìä Monitor: sudo journalctl -u story -f\"\nEOF\n\nchmod +x $HOME/emergency_snapshot_recovery.sh\n```\n\n## üîß Hardware Failure Recovery\n\n### Migrate to New Server\n\n```bash\n# Migration checklist for hardware failure\ncat > $HOME/migration_checklist.txt << 'EOF'\nüîß HARDWARE FAILURE MIGRATION CHECKLIST\n=======================================\n\nPRIORITY 1 - CRITICAL FILES (BACKUP THESE FIRST):\n‚ñ° priv_validator_key.json (MOST IMPORTANT)\n‚ñ° priv_validator_state.json\n‚ñ° node_key.json\n‚ñ° .env file (if using)\n\nPRIORITY 2 - CONFIGURATION:\n‚ñ° config.toml (port settings, peers)\n‚ñ° genesis.json\n‚ñ° addrbook.json\n\nPRIORITY 3 - OPTIONAL (if time permits):\n‚ñ° keyring files\n‚ñ° service files\n‚ñ° custom scripts\n\nNEW SERVER SETUP:\n1. Install dependencies and Go\n2. Build Story binaries\n3. Setup Cosmovisor\n4. Restore critical files\n5. Configure ports\n6. Use snapshot for quick sync\n7. Start services\n8. Verify validator is signing\n\nEMERGENCY CONTACTS:\n- Discord: https://discord.gg/storyprotocol\n- Telegram: https://t.me/storyprotocol\n- Community: Search for \"Story Protocol validator help\"\nEOF\n\necho \"üìã Migration checklist created: $HOME/migration_checklist.txt\"\n```\n\n### Quick Migration Script\n\n```bash\n# Quick setup for new server (after backing up keys)\ncat > $HOME/quick_migration_setup.sh << 'EOF'\n#!/bin/bash\n\necho \"‚ö° Quick Migration Setup\"\necho \"=======================\"\n\n# This assumes you have your validator keys ready\nif [ ! -f \"./priv_validator_key.json\" ]; then\n    echo \"‚ùå Place priv_validator_key.json in current directory first!\"\n    exit 1\nfi\n\necho \"üöÄ Starting quick setup...\"\n\n# System setup\nsudo apt update && sudo apt upgrade -y\nsudo apt install -y curl git wget htop tmux build-essential jq make lz4 gcc unzip aria2 bc\n\n# Install Go\ncd $HOME\nwget \"https://golang.org/dl/go1.22.11.linux-amd64.tar.gz\"\nsudo rm -rf /usr/local/go\nsudo tar -C /usr/local -xzf \"go1.22.11.linux-amd64.tar.gz\"\nrm \"go1.22.11.linux-amd64.tar.gz\"\necho \"export PATH=$PATH:/usr/local/go/bin:~/go/bin\" >> ~/.bash_profile\nsource ~/.bash_profile\n\n# Set variables\necho \"export STORY_MONIKER=\\\"MigratedValidator\\\"\" >> $HOME/.bash_profile\necho \"export STORY_PORT=\\\"26\\\"\" >> $HOME/.bash_profile\nsource $HOME/.bash_profile\n\n# Build binaries\ngit clone https://github.com/piplabs/story-geth.git\ncd story-geth && git checkout v1.1.1\ngo build -v ./cmd/geth && mv ./geth $HOME/go/bin/story-geth\ncd ..\n\ngit clone https://github.com/piplabs/story\ncd story && git checkout v1.3.0\ngo build -o story ./client && mv ./story $HOME/go/bin/story\ncd ..\n\n# Install cosmovisor\ngo install cosmossdk.io/tools/cosmovisor/cmd/cosmovisor@v1.6.0\n\n# Initialize\nstory init --moniker $STORY_MONIKER --network aeneid\n\n# Setup cosmovisor\necho \"export DAEMON_NAME=story\" >> $HOME/.bash_profile\necho \"export DAEMON_HOME=$HOME/.story/story\" >> $HOME/.bash_profile\necho \"export DAEMON_ALLOW_DOWNLOAD_BINARIES=false\" >> $HOME/.bash_profile\necho \"export DAEMON_RESTART_AFTER_UPGRADE=true\" >> $HOME/.bash_profile\nsource $HOME/.bash_profile\ncosmovisor init $(which story)\n\n# Restore validator key\ncp ./priv_validator_key.json $HOME/.story/story/config/\nchmod 600 $HOME/.story/story/config/priv_validator_key.json\n\n# Download genesis and configure\nwget -O $HOME/.story/story/config/genesis.json https://raw.githubusercontent.com/coinsspor/Story-Aeneid/refs/heads/main/genesis.json\nwget -O $HOME/.story/story/config/addrbook.json https://raw.githubusercontent.com/coinsspor/Story-Aeneid/refs/heads/main/addrbook.json\n\n# Configure ports and peers\nsed -i.bak -e \"s%:1317%:${STORY_PORT}317%g; s%:8551%:${STORY_PORT}551%g\" $HOME/.story/story/config/story.toml\nsed -i.bak -e \"s%:26658%:${STORY_PORT}658%g; s%:26657%:${STORY_PORT}657%g; s%:26656%:${STORY_PORT}656%g\" $HOME/.story/story/config/config.toml\n\n# Get fresh peers\nURL=\"https://story-aeneid-testnet-rpc.coinsspor.com/net_info\"\nPEERS=$(curl -s $URL | jq -r '.result.peers[] | select(.remote_ip | test(\"^[0-9]{1,3}(\\\\.[0-9]{1,3}){3}$\")) | \"\\(.node_info.id)@\\(.remote_ip):\" + (.node_info.listen_addr | capture(\":(?<port>[0-9]+)$\").port)' | paste -sd \",\" -)\nsed -i 's|^persistent_peers *=.*|persistent_peers = \"'$PEERS'\"|' $HOME/.story/story/config/config.toml\n\necho \"‚úÖ Quick setup completed!\"\necho \"üìã Next steps:\"\necho \"1. Create service files\"\necho \"2. Use snapshot for quick sync\"\necho \"3. Start services\"\necho \"4. Monitor validator status\"\nEOF\n\nchmod +x $HOME/quick_migration_setup.sh\n```\n\n## üìû Emergency Contacts\n\n```bash\necho \"üìû Emergency Support Contacts:\"\necho \"==============================\"\necho \"üéÆ Discord: https://discord.gg/storyprotocol\"\necho \"üì± Telegram: https://t.me/storyprotocol\"\necho \"üêõ GitHub Issues: https://github.com/piplabs/story/issues\"\necho \"üåü Coinsspor Support: https://t.me/coinsspor\"\necho \"üìß Community Forums: Search 'Story Protocol validator emergency'\"\necho \"==============================\"\necho \"üìã When asking for help, provide:\"\necho \"   - Error messages from logs\"\necho \"   - Output of: story version\"\necho \"   - Output of: systemctl status story story-geth\"\necho \"   - Node height vs network height\"\necho \"   - Whether you have validator key backup\"\n```\n\n:::danger\n**Emergency Priorities:**\n\n1. **Validator Key Safety**: Never lose your `priv_validator_key.json`\n2. **Double Signing Prevention**: Never run the same validator key on multiple servers\n3. **Quick Recovery**: Use snapshots to minimize downtime\n4. **Community Help**: Don't hesitate to ask for help in Discord/Telegram\n5. **Monitor Uptime**: Every minute offline affects your competition score\n:::"
        }
      ]
    },
    {
      "id": "support-community",
      "title": "Support & Community",
      "icon": "üìû",
      "type": "section",
      "children": [
        {
          "id": "support-channels",
          "title": "Support Channels",
          "icon": "üÜò",
          "type": "page",
          "content": "# üÜò Support Channels\n\n## üìû Official Support Channels\n\n| Platform | Link | Purpose | Response Time |\n|----------|------|---------|---------------|\n| **Discord** | [https://discord.gg/storyprotocol](https://discord.gg/storyprotocol) | Real-time community support | Minutes to hours |\n| **Telegram** | [https://t.me/storyprotocol](https://t.me/storyprotocol) | Official announcements & support | Hours |\n| **GitHub Issues** | [https://github.com/piplabs/story/issues](https://github.com/piplabs/story/issues) | Bug reports & technical issues | 1-3 days |\n| **Documentation** | [https://docs.story.foundation](https://docs.story.foundation) | Self-service help | Immediate |\n\n## üåü Community Support\n\n| Platform | Link | Purpose |\n|----------|------|----------|\n| **Coinsspor Support** | [https://t.me/coinsspor](https://t.me/coinsspor) | Node setup & infrastructure help |\n| **Reddit** | [r/StoryProtocol](https://reddit.com/r/StoryProtocol) | Community discussions |\n| **Twitter/X** | [@Story_Protocol](https://twitter.com/Story_Protocol) | News & updates |\n\n## üéØ When to Use Each Channel\n\n### üéÆ Discord (Best for Quick Help)\n**Use for:**\n- Urgent validator issues\n- Setup problems\n- Real-time troubleshooting\n- Community discussions\n\n**Channels to check:**\n- `#validator-support`\n- `#technical-help`\n- `#announcements`\n- `#general`\n\n### üì± Telegram (Official Updates)\n**Use for:**\n- Official announcements\n- Network updates\n- Upgrade notifications\n- General questions\n\n### üêõ GitHub Issues (Technical Problems)\n**Use for:**\n- Software bugs\n- Feature requests\n- Code-related issues\n- Reproducible problems\n\n### üìö Documentation (Self-Help)\n**Use for:**\n- API references\n- Setup guides\n- Configuration help\n- Best practices\n\n## üìã How to Get Effective Help\n\n### üîß Prepare Information Before Asking\n\n```bash\n# Create support information script\ncat > $HOME/gather_support_info.sh << 'EOF'\n#!/bin/bash\n\necho \"üìã Story Protocol Support Information\"\necho \"====================================\"\necho \"üìÖ Generated: $(date)\"\necho \"\"\n\n# System information\necho \"üñ•Ô∏è System Information:\"\necho \"OS: $(lsb_release -d | cut -f2)\"\necho \"Architecture: $(uname -m)\"\necho \"Kernel: $(uname -r)\"\necho \"RAM: $(free -h | awk '/^Mem:/ {print $2}')\"\necho \"Disk: $(df -h $HOME/.story | awk 'NR==2 {print $4 \" available / \" $2 \" total\"}')\"\necho \"\"\n\n# Software versions\necho \"üì¶ Software Versions:\"\necho \"Story: $(story version 2>/dev/null || echo 'Not found')\"\necho \"Story-Geth: $(story-geth version 2>/dev/null | head -1 || echo 'Not found')\"\necho \"Cosmovisor: $(cosmovisor version 2>/dev/null || echo 'Not found')\"\necho \"Go: $(go version 2>/dev/null || echo 'Not found')\"\necho \"\"\n\n# Service status\necho \"üîß Service Status:\"\necho \"Story: $(systemctl is-active story 2>/dev/null || echo 'unknown')\"\necho \"Story-Geth: $(systemctl is-active story-geth 2>/dev/null || echo 'unknown')\"\necho \"\"\n\n# Network status\necho \"üåê Network Status:\"\nif curl -s --max-time 5 localhost:${STORY_PORT}657/status >/dev/null 2>&1; then\n    HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\n    CATCHING_UP=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.catching_up')\n    PEERS=$(curl -s localhost:${STORY_PORT}657/net_info | jq -r '.result.n_peers')\n    \n    echo \"Node Height: $HEIGHT\"\n    echo \"Catching Up: $CATCHING_UP\"\n    echo \"Connected Peers: $PEERS\"\nelse\n    echo \"‚ùå Node not responding\"\nfi\necho \"\"\n\n# Configuration\necho \"‚öôÔ∏è Configuration:\"\necho \"Moniker: $STORY_MONIKER\"\necho \"Port Prefix: $STORY_PORT\"\necho \"RPC Port: ${STORY_PORT}657\"\necho \"\"\n\n# Recent errors\necho \"‚ö†Ô∏è Recent Errors (last 10 minutes):\"\necho \"Story errors:\"\nsudo journalctl -u story --since \"10 minutes ago\" | grep -i \"error\\|fail\\|panic\" | tail -3\necho \"\\nGeth errors:\"\nsudo journalctl -u story-geth --since \"10 minutes ago\" | grep -i \"error\\|fail\\|panic\" | tail -3\n\necho \"\"\necho \"====================================\"\necho \"üí° Copy this information when asking for help\"\nEOF\n\nchmod +x $HOME/gather_support_info.sh\n\n# Run the script\n./gather_support_info.sh\n```\n\n### ‚úÖ Support Request Template\n\n```markdown\n## üÜò Support Request Template\n\n**Problem Description:**\n[Clearly describe what's happening and what you expected]\n\n**Steps to Reproduce:**\n1. [First step]\n2. [Second step]\n3. [Third step]\n\n**Environment:**\n- OS: [Ubuntu 22.04 LTS]\n- Story Version: [v1.3.0]\n- Story-Geth Version: [v1.1.1]\n- Node Type: [Validator/Full Node]\n\n**Error Messages:**\n```\n[Paste exact error messages here]\n```\n\n**Logs:**\n```\n[Paste relevant logs here]\n```\n\n**Additional Context:**\n[Any other relevant information]\n```\n\n## üéØ Common Support Scenarios\n\n### üö® Validator Emergencies\n**When:** Validator offline, missing blocks\n**Where:** Discord `#validator-support`\n**Include:**\n- Validator address\n- How long offline\n- Error messages\n- Last successful block height\n\n### üîß Setup Issues\n**When:** Installation problems, service failures\n**Where:** Discord `#technical-help` or Telegram\n**Include:**\n- Setup step you're stuck on\n- Error messages\n- System information\n- What you've tried\n\n### üêõ Software Bugs\n**When:** Unexpected behavior, crashes\n**Where:** GitHub Issues\n**Include:**\n- Reproducible steps\n- Expected vs actual behavior\n- Environment details\n- Debug logs\n\n### üìä Performance Issues\n**When:** Slow sync, high resource usage\n**Where:** Discord `#technical-help`\n**Include:**\n- System specifications\n- Resource usage stats\n- Network connectivity\n- Configuration details\n\n## üîç Self-Help Resources\n\n### üìö Documentation Links\n- **Official Docs**: [https://docs.story.foundation](https://docs.story.foundation)\n- **API Reference**: [https://docs.story.foundation/api](https://docs.story.foundation/api)\n- **Validator Guide**: [https://docs.story.foundation/validators](https://docs.story.foundation/validators)\n\n### üõ†Ô∏è Diagnostic Tools\n\n```bash\n# Create quick diagnostic toolkit\ncat > $HOME/diagnostic_toolkit.sh << 'EOF'\n#!/bin/bash\n\necho \"üõ†Ô∏è Story Protocol Diagnostic Toolkit\"\necho \"====================================\"\n\n# Quick health check\necho \"üè• Quick Health Check:\"\necho \"Services: $(systemctl is-active story) / $(systemctl is-active story-geth)\"\necho \"Node responding: $(curl -s --max-time 3 localhost:${STORY_PORT}657/status >/dev/null && echo 'Yes' || echo 'No')\"\necho \"Peers: $(curl -s localhost:${STORY_PORT}657/net_info | jq -r '.result.n_peers' 2>/dev/null || echo 'N/A')\"\necho \"\"\n\n# Port check\necho \"üîå Port Status:\"\nfor port in ${STORY_PORT}657 ${STORY_PORT}656 ${STORY_PORT}545; do\n    if netstat -tuln | grep -q \":$port \"; then\n        echo \"‚úÖ Port $port: Active\"\n    else\n        echo \"‚ùå Port $port: Inactive\"\n    fi\ndone\necho \"\"\n\n# Disk space\necho \"üíæ Disk Space:\"\ndf -h $HOME/.story | awk 'NR==2 {print \"Story data: \" $3 \"/\" $2 \" (\" $5 \" used)\"}')\necho \"\"\n\n# Recent crashes\necho \"üí• Recent Crashes:\"\nCRASHES=$(sudo journalctl -u story -u story-geth --since \"1 hour ago\" | grep -c \"Failed\\|Error\\|Panic\")\necho \"Error count (last hour): $CRASHES\"\n\necho \"====================================\"\nEOF\n\nchmod +x $HOME/diagnostic_toolkit.sh\n```\n\n### üîß Common Commands Reference\n\n```bash\n# Save common commands for quick reference\ncat > $HOME/common_commands.txt << 'EOF'\nüìã Story Protocol Common Commands\n================================\n\nüîß Service Management:\nsudo systemctl status story story-geth\nsudo systemctl restart story story-geth\nsudo journalctl -u story -f\n\nüìä Node Status:\ncurl localhost:${STORY_PORT}657/status | jq '.result.sync_info'\ncurl localhost:${STORY_PORT}657/net_info | jq '.result.n_peers'\n\nüèÜ Validator:\nstory validator export\nstory validator status\nstory keys show validator --keyring-backend test\n\nüí∞ Wallet:\nstory keys list --keyring-backend test\nstory query bank balances [ADDRESS]\n\nüîÑ Upgrades:\ncosmovisor version\nls -la $HOME/.story/story/cosmovisor/upgrades/\n\nüõ†Ô∏è Troubleshooting:\n./gather_support_info.sh\n./diagnostic_toolkit.sh\n./health_check.sh\nEOF\n\necho \"üìã Common commands saved to: $HOME/common_commands.txt\"\n```\n\n## üåü Community Guidelines\n\n### ‚úÖ Do's\n- Be respectful and patient\n- Search previous messages before asking\n- Provide detailed information\n- Help others when you can\n- Follow channel rules\n\n### ‚ùå Don'ts\n- Don't spam or repeat questions\n- Don't share private keys or sensitive info\n- Don't ask for direct messages unless requested\n- Don't post unrelated content\n- Don't ping moderators unnecessarily\n\n## üéÅ Contributing Back\n\n### üìù Help Documentation\n- Report documentation errors\n- Suggest improvements\n- Share your setup experiences\n- Create tutorials\n\n### ü§ù Help Others\n- Answer questions in Discord\n- Share troubleshooting tips\n- Report bugs you find\n- Test new features\n\n### üí° Feature Requests\n- Suggest new features\n- Provide use cases\n- Participate in discussions\n- Test beta features\n\n:::tip\n**Getting Help Effectively:**\n1. **Search First**: Check docs and previous discussions\n2. **Be Specific**: Describe exactly what's happening\n3. **Provide Context**: Include system info and logs\n4. **Be Patient**: Community volunteers help in their free time\n5. **Say Thanks**: Acknowledge help received\n:::"
        }
      ]
    }
  ],\n  \"lastUpdated\": \"2025-01-13T10:30:00Z\",\n  \"projectId\": \"story-protocol\",\n  \"version\": \"1.0.0\"\n}    # CPU and Memory usage\n    echo \"üíª Resource Usage:\"\n    ps aux | grep -E \"(story|geth|cosmovisor)\" | grep -v grep | awk '{print $11 \": CPU \" $3 \"%, MEM \" $4 \"%\"}'\n    \n    # Service status\n    echo \"\\nüîß Service Status:\"\n    systemctl is-active story >/dev/null && echo \"‚úÖ Story: Active\" || echo \"‚ùå Story: Inactive\"\n    systemctl is-active story-geth >/dev/null && echo \"‚úÖ Story-Geth: Active\" || echo \"‚ùå Story-Geth: Inactive\"\n    \n    # Network status\n    echo \"\\nüåê Network Status:\"\n    PEERS=$(curl -s localhost:${STORY_PORT}657/net_info 2>/dev/null | jq -r '.result.n_peers' 2>/dev/null || echo \"N/A\")\n    HEIGHT=$(curl -s localhost:${STORY_PORT}657/status 2>/dev/null | jq -r '.result.sync_info.latest_block_height' 2>/dev/null || echo \"N/A\")\n    echo \"üì° Peers: $PEERS\"\n    echo \"üìä Height: $HEIGHT\"\n    \n    echo \"\\n==============================\"\n    echo \"Press Ctrl+C to exit\"\n    sleep 5\ndone\nEOF\n\nchmod +x $HOME/performance_monitor.sh\n```\n\n## üö® Emergency Recovery\n\n```bash\n# Emergency service recovery script\ncat > $HOME/emergency_recovery.sh << 'EOF'\n#!/bin/bash\n\necho \"üö® Emergency Service Recovery\"\necho \"=============================\"\n\n# Stop everything\necho \"üõë Force stopping all processes...\"\nsudo systemctl stop story story-geth\nsudo pkill -f story\nsudo pkill -f geth\nsudo pkill -f cosmovisor\nsleep 5\n\n# Check for zombie processes\necho \"üîç Checking for remaining processes...\"\nps aux | grep -E \"(story|geth|cosmovisor)\" | grep -v grep\n\n# Verify critical files\necho \"üìÅ Checking critical files...\"\nif [ ! -f \"$HOME/.story/story/config/priv_validator_key.json\" ]; then\n    echo \"‚ùå CRITICAL: Validator key missing!\"\n    exit 1\nelse\n    echo \"‚úÖ Validator key exists\"\nfi\n\nif [ ! -x \"$HOME/go/bin/story\" ]; then\n    echo \"‚ùå CRITICAL: Story binary missing or not executable!\"\n    exit 1\nelse\n    echo \"‚úÖ Story binary OK\"\nfi\n\nif [ ! -x \"$HOME/go/bin/story-geth\" ]; then\n    echo \"‚ùå CRITICAL: Story-Geth binary missing or not executable!\"\n    exit 1\nelse\n    echo \"‚úÖ Story-Geth binary OK\"\nfi\n\n# Restart services\necho \"üöÄ Restarting services...\"\nsudo systemctl daemon-reload\nsudo systemctl start story-geth\necho \"‚è≥ Waiting 20 seconds for Geth...\"\nsleep 20\n\nsudo systemctl start story\necho \"‚è≥ Waiting 10 seconds for Story...\"\nsleep 10\n\n# Verify recovery\necho \"‚úÖ Recovery Status:\"\nsudo systemctl is-active story && echo \"‚úÖ Story: Recovered\" || echo \"‚ùå Story: Failed\"\nsudo systemctl is-active story-geth && echo \"‚úÖ Story-Geth: Recovered\" || echo \"‚ùå Story-Geth: Failed\"\n\necho \"=============================\"\necho \"üè• Emergency recovery completed\"\nEOF\n\nchmod +x $HOME/emergency_recovery.sh\n```\n\n## üîß Useful Aliases\n\n```bash\n# Add helpful aliases to bash profile\ncat >> $HOME/.bash_profile << 'EOF'\n\n# Story Protocol Service Aliases\nalias story-start='sudo systemctl start story-geth && sleep 10 && sudo systemctl start story'\nalias story-stop='sudo systemctl stop story && sudo systemctl stop story-geth'\nalias story-restart='sudo systemctl restart story story-geth'\nalias story-status='sudo systemctl status story story-geth --no-pager'\nalias story-logs='sudo journalctl -u story -f'\nalias geth-logs='sudo journalctl -u story-geth -f'\nalias story-all-logs='sudo journalctl -u story -u story-geth -f'\n\n# Story Protocol Monitoring Aliases\nalias story-height='curl -s localhost:${STORY_PORT}657/status | jq -r \".result.sync_info.latest_block_height\"'\nalias story-sync='curl -s localhost:${STORY_PORT}657/status | jq -r \".result.sync_info.catching_up\"'\nalias story-peers='curl -s localhost:${STORY_PORT}657/net_info | jq -r \".result.n_peers\"'\nalias story-validator='curl -s localhost:${STORY_PORT}657/status | jq -r \".result.validator_info\"'\n\n# Story Protocol Utility Aliases\nalias story-version='story version && story-geth version'\nalias story-health='curl -s localhost:${STORY_PORT}657/health'\nalias story-config='cat $HOME/.story/story/config/config.toml | grep -E \"(seeds|persistent_peers|laddr)\"'\n\nEOF\n\nsource $HOME/.bash_profile\necho \"‚úÖ Aliases added! Use 'story-start', 'story-logs', etc.\"\n```"
        },
        {
          "id": "node-information",
          "title": "Node Information",
          "icon": "üìä",
          "type": "page",
          "content": "# üìä Node Information\n\n## üîç Basic Node Information\n\n```bash\n# Get node ID\ncurl localhost:${STORY_PORT}657/status | jq '.result.node_info.id'\n\n# Get node info with details\ncurl localhost:${STORY_PORT}657/status | jq '.result.node_info'\n\n# Get validator address\nstory status 2>&1 | jq '.ValidatorInfo.address'\n\n# Get node version\ncurl localhost:${STORY_PORT}657/status | jq '.result.node_info.version'\n```\n\n## üìà Sync Information\n\n```bash\n# Check node sync info\ncurl localhost:${STORY_PORT}657/status | jq '.result.sync_info'\n\n# Get specific sync details\nSYNC_INFO=$(curl -s localhost:${STORY_PORT}657/status | jq '.result.sync_info')\necho \"Latest Height: $(echo $SYNC_INFO | jq -r '.latest_block_height')\"\necho \"Catching Up: $(echo $SYNC_INFO | jq -r '.catching_up')\"\necho \"Latest Block Time: $(echo $SYNC_INFO | jq -r '.latest_block_time')\"\necho \"Earliest Block Height: $(echo $SYNC_INFO | jq -r '.earliest_block_height')\"\n\n# Compare with network height\nLOCAL_HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\nNETWORK_HEIGHT=$(curl -s https://aeneid.storyrpc.io/status | jq -r '.result.sync_info.latest_block_height')\nBLOCKS_BEHIND=$((NETWORK_HEIGHT - LOCAL_HEIGHT))\n\necho \"üìä Sync Comparison:\"\necho \"Local Height: $LOCAL_HEIGHT\"\necho \"Network Height: $NETWORK_HEIGHT\"\necho \"Blocks Behind: $BLOCKS_BEHIND\"\n```\n\n## üåê Network Information\n\n```bash\n# Check number of connected peers\ncurl -s localhost:${STORY_PORT}657/net_info | jq '.result.n_peers'\n\n# Get detailed peer information\ncurl -s localhost:${STORY_PORT}657/net_info | jq '.result.peers[] | {id: .node_info.id, moniker: .node_info.moniker, remote_ip: .remote_ip}'\n\n# Check peer details with connection info\ncurl -s localhost:${STORY_PORT}657/net_info | jq -r '.result.peers[] | \"\\(.node_info.id)@\\(.remote_ip):\\(.node_info.listen_addr | capture(\":(?<port>[0-9]+)$\").port) - \\(.node_info.moniker)\"'\n\n# Check listening address\ncurl localhost:${STORY_PORT}657/status | jq '.result.node_info.listen_addr'\n```\n\n## üèÜ Validator Information\n\n```bash\n# Get validator info (if running as validator)\ncurl localhost:${STORY_PORT}657/status | jq '.result.validator_info'\n\n# Check if node is a validator\nVALIDATOR_ADDR=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.validator_info.address')\nif [ \"$VALIDATOR_ADDR\" != \"null\" ] && [ -n \"$VALIDATOR_ADDR\" ]; then\n    echo \"‚úÖ This node is a validator\"\n    echo \"üìç Validator Address: $VALIDATOR_ADDR\"\nelse\n    echo \"‚ÑπÔ∏è  This node is not a validator\"\nfi\n\n# Check validator in validator set\nif [ -n \"$VALIDATOR_ADDR\" ] && [ \"$VALIDATOR_ADDR\" != \"null\" ]; then\n    curl localhost:${STORY_PORT}657/validators | jq --arg addr \"$VALIDATOR_ADDR\" '.result.validators[] | select(.address==$addr)'\nfi\n```\n\n## üîß Detailed Node Diagnostics\n\n```bash\n# Create comprehensive node info script\ncat > $HOME/node_info.sh << 'EOF'\n#!/bin/bash\n\nsource $HOME/.bash_profile\n\necho \"üìä Story Protocol Node Information\"\necho \"==================================\"\n\n# Basic node information\necho \"üîç Basic Information:\"\nNODE_ID=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.node_info.id')\nNODE_MONIKER=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.node_info.moniker')\nNODE_VERSION=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.node_info.version')\nCHAIN_ID=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.node_info.network')\n\necho \"üìõ Node ID: $NODE_ID\"\necho \"üè∑Ô∏è  Moniker: $NODE_MONIKER\"\necho \"üìå Version: $NODE_VERSION\"\necho \"üåê Chain ID: $CHAIN_ID\"\necho \"üîå RPC Port: ${STORY_PORT}657\"\n\n# Sync information\necho \"\\nüìà Sync Information:\"\nSYNC_INFO=$(curl -s localhost:${STORY_PORT}657/status | jq '.result.sync_info')\nLATEST_HEIGHT=$(echo $SYNC_INFO | jq -r '.latest_block_height')\nCATCHING_UP=$(echo $SYNC_INFO | jq -r '.catching_up')\nLATEST_BLOCK_TIME=$(echo $SYNC_INFO | jq -r '.latest_block_time')\n\necho \"üìä Latest Height: $LATEST_HEIGHT\"\necho \"üîÑ Catching Up: $CATCHING_UP\"\necho \"‚è∞ Latest Block Time: $LATEST_BLOCK_TIME\"\n\n# Network comparison\nNETWORK_HEIGHT=$(curl -s https://aeneid.storyrpc.io/status 2>/dev/null | jq -r '.result.sync_info.latest_block_height' 2>/dev/null || echo \"N/A\")\nif [[ \"$NETWORK_HEIGHT\" =~ ^[0-9]+$ ]] && [[ \"$LATEST_HEIGHT\" =~ ^[0-9]+$ ]]; then\n    BLOCKS_BEHIND=$((NETWORK_HEIGHT - LATEST_HEIGHT))\n    echo \"üåç Network Height: $NETWORK_HEIGHT\"\n    echo \"‚è≥ Blocks Behind: $BLOCKS_BEHIND\"\nfi\n\n# Peer information\necho \"\\nüåê Network Information:\"\nPEER_COUNT=$(curl -s localhost:${STORY_PORT}657/net_info | jq -r '.result.n_peers')\necho \"üë• Connected Peers: $PEER_COUNT\"\n\n# Validator information\necho \"\\nüëë Validator Information:\"\nVALIDATOR_INFO=$(curl -s localhost:${STORY_PORT}657/status | jq '.result.validator_info')\nVALIDATOR_ADDR=$(echo $VALIDATOR_INFO | jq -r '.address')\nVOTING_POWER=$(echo $VALIDATOR_INFO | jq -r '.voting_power')\n\nif [ \"$VALIDATOR_ADDR\" != \"null\" ] && [ -n \"$VALIDATOR_ADDR\" ]; then\n    echo \"‚úÖ Validator Status: Active\"\n    echo \"üìç Validator Address: $VALIDATOR_ADDR\"\n    echo \"‚ö° Voting Power: $VOTING_POWER\"\nelse\n    echo \"‚ÑπÔ∏è  Validator Status: Not a validator\"\nfi\n\n# Service status\necho \"\\nüîß Service Status:\"\nSTORY_STATUS=$(systemctl is-active story 2>/dev/null)\nGETH_STATUS=$(systemctl is-active story-geth 2>/dev/null)\necho \"üì¶ Story Service: $STORY_STATUS\"\necho \"‚ö° Geth Service: $GETH_STATUS\"\n\n# Binary versions\necho \"\\nüìã Binary Versions:\"\necho \"üèóÔ∏è  Story: $(story version 2>/dev/null || echo 'Not found')\"\necho \"‚ö° Story-Geth: $(story-geth version 2>/dev/null | head -1 || echo 'Not found')\"\necho \"üîÑ Cosmovisor: $(cosmovisor version 2>/dev/null || echo 'Not found')\"\n\necho \"==================================\"\nEOF\n\nchmod +x $HOME/node_info.sh\n\n# Run the script\n./node_info.sh\n```\n\n## üì° API Endpoint Testing\n\n```bash\n# Test all API endpoints\ncat > $HOME/test_endpoints.sh << 'EOF'\n#!/bin/bash\n\nsource $HOME/.bash_profile\n\necho \"üì° API Endpoint Testing\"\necho \"======================\"\n\n# Test Story RPC endpoints\necho \"üîç Testing Story RPC Endpoints:\"\nENDPOINTS=(\n    \"/status\"\n    \"/health\"\n    \"/net_info\"\n    \"/validators\"\n    \"/genesis\"\n    \"/consensus_state\"\n)\n\nfor endpoint in \"${ENDPOINTS[@]}\"; do\n    echo -n \"Testing $endpoint: \"\n    if curl -s --max-time 5 \"localhost:${STORY_PORT}657$endpoint\" >/dev/null; then\n        echo \"‚úÖ OK\"\n    else\n        echo \"‚ùå Failed\"\n    fi\ndone\n\n# Test Story-Geth RPC endpoints\necho \"\\n‚ö° Testing Story-Geth RPC Endpoints:\"\nGETH_METHODS=(\n    \"eth_blockNumber\"\n    \"eth_chainId\"\n    \"net_version\"\n    \"net_peerCount\"\n    \"eth_syncing\"\n)\n\nfor method in \"${GETH_METHODS[@]}\"; do\n    echo -n \"Testing $method: \"\n    if curl -s --max-time 5 \"localhost:${STORY_PORT}545\" \\\n        -X POST \\\n        -H \"Content-Type: application/json\" \\\n        -d '{\"jsonrpc\":\"2.0\",\"method\":\"'$method'\",\"params\":[],\"id\":1}' >/dev/null; then\n        echo \"‚úÖ OK\"\n    else\n        echo \"‚ùå Failed\"\n    fi\ndone\n\n# Test WebSocket connection\necho \"\\nüîå Testing WebSocket Connection:\"\nif command -v wscat >/dev/null 2>&1; then\n    echo -n \"WebSocket test: \"\n    timeout 5 wscat -c \"ws://localhost:${STORY_PORT}546\" </dev/null >/dev/null 2>&1 && echo \"‚úÖ OK\" || echo \"‚ùå Failed\"\nelse\n    echo \"‚ÑπÔ∏è  wscat not installed, skipping WebSocket test\"\nfi\n\necho \"======================\"\nEOF\n\nchmod +x $HOME/test_endpoints.sh\n```\n\n## üîé Advanced Node Queries\n\n```bash\n# Get consensus state\ncurl localhost:${STORY_PORT}657/consensus_state | jq '.result.round_state'\n\n# Get genesis file info\ncurl localhost:${STORY_PORT}657/genesis | jq '.result.genesis | {chain_id, genesis_time, consensus_params}'\n\n# Get ABCI info\ncurl localhost:${STORY_PORT}657/abci_info | jq '.result'\n\n# Get unconfirmed transactions\ncurl localhost:${STORY_PORT}657/unconfirmed_txs | jq '.result'\n\n# Get block information\nLATEST_HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\ncurl localhost:${STORY_PORT}657/block?height=$LATEST_HEIGHT | jq '.result.block.header'\n\n# Get commit information\ncurl localhost:${STORY_PORT}657/commit?height=$LATEST_HEIGHT | jq '.result.signed_header.commit'\n```\n\n## üìä Performance Metrics\n\n```bash\n# Get Prometheus metrics (if enabled)\ncurl -s localhost:${STORY_PORT}660/metrics | grep -E \"(height|peers|consensus)\"\n\n# Get Geth metrics (if enabled)\ncurl -s localhost:${STORY_PORT}060/debug/metrics | jq '.p2p.peers'\n\n# Monitor block production rate\ncat > $HOME/block_rate_monitor.sh << 'EOF'\n#!/bin/bash\n\necho \"üìä Block Production Rate Monitor\"\necho \"================================\"\n\nPREV_HEIGHT=0\nPREV_TIME=$(date +%s)\n\nwhile true; do\n    CURRENT_HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\n    CURRENT_TIME=$(date +%s)\n    \n    if [ $PREV_HEIGHT -ne 0 ]; then\n        BLOCKS_DIFF=$((CURRENT_HEIGHT - PREV_HEIGHT))\n        TIME_DIFF=$((CURRENT_TIME - PREV_TIME))\n        \n        if [ $TIME_DIFF -gt 0 ]; then\n            RATE=$(echo \"scale=2; $BLOCKS_DIFF / $TIME_DIFF\" | bc -l)\n            echo \"üìà Height: $CURRENT_HEIGHT | Rate: $RATE blocks/sec | Blocks in ${TIME_DIFF}s: $BLOCKS_DIFF\"\n        fi\n    fi\n    \n    PREV_HEIGHT=$CURRENT_HEIGHT\n    PREV_TIME=$CURRENT_TIME\n    sleep 10\ndone\nEOF\n\nchmod +x $HOME/block_rate_monitor.sh\n```"
        },
        {
          "id": "wallet-operations",
          "title": "Wallet Operations",
          "icon": "üí∞",
          "type": "page",
          "content": "# üí∞ Wallet Operations\n\n## üîë Key Management\n\n```bash\n# List all keys\nstory keys list --keyring-backend test\n\n# Show specific key details\nstory keys show validator --keyring-backend test\n\n# Get key address\nKEY_ADDRESS=$(story keys show validator --keyring-backend test --output json | jq -r '.address')\necho \"üíº Wallet Address: $KEY_ADDRESS\"\n\n# Export key information\nstory keys show validator --keyring-backend test --output json\n```\n\n## üí∏ Balance Operations\n\n```bash\n# Check balance (replace YOUR_ADDRESS with actual address)\nKEY_ADDRESS=$(story keys show validator --keyring-backend test --output json 2>/dev/null | jq -r '.address')\n\nif [ \"$KEY_ADDRESS\" != \"null\" ] && [ -n \"$KEY_ADDRESS\" ]; then\n    echo \"üí∞ Checking balance for: $KEY_ADDRESS\"\n    curl -s \"https://aeneid.storyrpc.io/cosmos/bank/v1beta1/balances/$KEY_ADDRESS\" | jq '.balances'\nelse\n    echo \"‚ùå Could not determine wallet address\"\nfi\n\n# Check specific token balance\ncurl -s \"https://aeneid.storyrpc.io/cosmos/bank/v1beta1/balances/$KEY_ADDRESS/by_denom?denom=uip\" | jq '.balance'\n\n# Get all account information\ncurl -s \"https://aeneid.storyrpc.io/cosmos/auth/v1beta1/accounts/$KEY_ADDRESS\" | jq '.account'\n```\n\n## üì§ Send Transactions\n\n```bash\n# Navigate to config directory with .env file\ncd $HOME/.story/story/config/\n\n# Send tokens (replace addresses and adjust amount)\nstory tx bank send $KEY_ADDRESS RECIPIENT_ADDRESS 1000000000000000000000uip \\\n  --chain-id 1315 \\\n  --rpc https://aeneid.storyrpc.io \\\n  --gas-limit 200000 \\\n  --gas-price 1000000000uip\n\n# Send with automatic gas estimation\nstory tx bank send $KEY_ADDRESS RECIPIENT_ADDRESS 1000000000000000000000uip \\\n  --chain-id 1315 \\\n  --rpc https://aeneid.storyrpc.io \\\n  --gas auto \\\n  --gas-adjustment 1.2\n```\n\n## üîç Transaction Operations\n\n```bash\n# Check transaction status\nTX_HASH=\"your_transaction_hash\"\ncurl -s \"https://aeneid.storyrpc.io/cosmos/tx/v1beta1/txs/$TX_HASH\" | jq '.tx_response'\n\n# Get transaction by hash with detailed info\ncurl -s \"https://aeneid.storyrpc.io/cosmos/tx/v1beta1/txs/$TX_HASH\" | jq '{\n  txhash: .tx_response.txhash,\n  height: .tx_response.height,\n  code: .tx_response.code,\n  gas_used: .tx_response.gas_used,\n  gas_wanted: .tx_response.gas_wanted,\n  timestamp: .tx_response.timestamp\n}'\n\n# Search transactions by address\ncurl -s \"https://aeneid.storyrpc.io/cosmos/tx/v1beta1/txs?events=transfer.sender='$KEY_ADDRESS'\" | jq '.txs | length'\n```\n\n## üí± Token Conversion Utilities\n\n```bash\n# Create token conversion utilities\ncat > $HOME/token_utils.sh << 'EOF'\n#!/bin/bash\n\n# Convert IP to uip (wei)\nip_to_uip() {\n    if [ -z \"$1\" ]; then\n        echo \"Usage: ip_to_uip <amount_in_IP>\"\n        return 1\n    fi\n    \n    local ip_amount=$1\n    local uip_amount=$(echo \"$ip_amount * 1000000000000000000000\" | bc -l)\n    echo \"${uip_amount%.*}uip\"\n}\n\n# Convert uip to IP\nuip_to_ip() {\n    if [ -z \"$1\" ]; then\n        echo \"Usage: uip_to_ip <amount_in_uip>\"\n        return 1\n    fi\n    \n    local uip_amount=${1%uip}  # Remove 'uip' suffix if present\n    local ip_amount=$(echo \"scale=6; $uip_amount / 1000000000000000000000\" | bc -l)\n    echo \"${ip_amount} IP\"\n}\n\n# Check if function is called directly\nif [ \"${BASH_SOURCE[0]}\" = \"${0}\" ]; then\n    case \"$1\" in\n        \"ip_to_uip\")\n            ip_to_uip \"$2\"\n            ;;\n        \"uip_to_ip\")\n            uip_to_ip \"$2\"\n            ;;\n        *)\n            echo \"Usage: $0 [ip_to_uip|uip_to_ip] <amount>\"\n            echo \"Examples:\"\n            echo \"  $0 ip_to_uip 1000        # Convert 1000 IP to uip\"\n            echo \"  $0 uip_to_ip 1000000000000000000000  # Convert uip to IP\"\n            ;;\n    esac\nfi\nEOF\n\nchmod +x $HOME/token_utils.sh\n\n# Usage examples:\n# ./token_utils.sh ip_to_uip 1000\n# ./token_utils.sh uip_to_ip 1000000000000000000000\n\n# Or source the file to use functions directly:\n# source $HOME/token_utils.sh\n# ip_to_uip 1000\n```\n\n## üìä Advanced Wallet Information\n\n```bash\n# Create wallet information script\ncat > $HOME/wallet_info.sh << 'EOF'\n#!/bin/bash\n\necho \"üíº Wallet Information Dashboard\"\necho \"==============================\"\n\n# Get wallet address\nKEY_ADDRESS=$(story keys show validator --keyring-backend test --output json 2>/dev/null | jq -r '.address')\n\nif [ \"$KEY_ADDRESS\" = \"null\" ] || [ -z \"$KEY_ADDRESS\" ]; then\n    echo \"‚ùå No wallet found. Create a wallet first.\"\n    exit 1\nfi\n\necho \"üìç Wallet Address: $KEY_ADDRESS\"\n\n# Get balance information\necho \"\\nüí∞ Balance Information:\"\nBALANCE_INFO=$(curl -s \"https://aeneid.storyrpc.io/cosmos/bank/v1beta1/balances/$KEY_ADDRESS\")\n\nif echo \"$BALANCE_INFO\" | jq -e '.balances' >/dev/null 2>&1; then\n    echo \"$BALANCE_INFO\" | jq -r '.balances[] | \"üíé \\(.denom): \\(.amount)\"'\n    \n    # Convert uip to IP for readability\n    UIP_BALANCE=$(echo \"$BALANCE_INFO\" | jq -r '.balances[] | select(.denom==\"uip\") | .amount')\n    if [ \"$UIP_BALANCE\" != \"null\" ] && [ -n \"$UIP_BALANCE\" ]; then\n        IP_BALANCE=$(echo \"scale=6; $UIP_BALANCE / 1000000000000000000000\" | bc -l)\n        echo \"üìä Total IP: $IP_BALANCE IP\"\n    fi\nelse\n    echo \"‚ö†Ô∏è  Could not fetch balance information\"\nfi\n\n# Get account information\necho \"\\nüìã Account Information:\"\nACCOUNT_INFO=$(curl -s \"https://aeneid.storyrpc.io/cosmos/auth/v1beta1/accounts/$KEY_ADDRESS\")\n\nif echo \"$ACCOUNT_INFO\" | jq -e '.account' >/dev/null 2>&1; then\n    ACCOUNT_NUMBER=$(echo \"$ACCOUNT_INFO\" | jq -r '.account.account_number')\n    SEQUENCE=$(echo \"$ACCOUNT_INFO\" | jq -r '.account.sequence')\n    echo \"üî¢ Account Number: $ACCOUNT_NUMBER\"\n    echo \"üìä Sequence: $SEQUENCE\"\nelse\n    echo \"‚ÑπÔ∏è  Account not found on chain (no transactions yet)\"\nfi\n\n# Get delegation information\necho \"\\nü•© Staking Information:\"\nDELEGATIONS=$(curl -s \"https://aeneid.storyrpc.io/cosmos/staking/v1beta1/delegations/$KEY_ADDRESS\")\n\nif echo \"$DELEGATIONS\" | jq -e '.delegation_responses' >/dev/null 2>&1; then\n    DELEGATION_COUNT=$(echo \"$DELEGATIONS\" | jq '.delegation_responses | length')\n    echo \"üìä Active Delegations: $DELEGATION_COUNT\"\n    \n    if [ \"$DELEGATION_COUNT\" -gt 0 ]; then\n        echo \"$DELEGATIONS\" | jq -r '.delegation_responses[] | \"üéØ Validator: \\(.delegation.validator_address)\\nüí∞ Amount: \\(.balance.amount) \\(.balance.denom)\"'\n    fi\nelse\n    echo \"‚ÑπÔ∏è  No delegations found\"\nfi\n\n# Get recent transactions\necho \"\\nüìú Recent Transactions (last 5):\"\nTX_SEARCH=$(curl -s \"https://aeneid.storyrpc.io/cosmos/tx/v1beta1/txs?events=message.sender='$KEY_ADDRESS'&limit=5&order_by=2\")\n\nif echo \"$TX_SEARCH\" | jq -e '.txs' >/dev/null 2>&1; then\n    TX_COUNT=$(echo \"$TX_SEARCH\" | jq '.txs | length')\n    echo \"üìä Found $TX_COUNT recent transactions\"\n    \n    if [ \"$TX_COUNT\" -gt 0 ]; then\n        echo \"$TX_SEARCH\" | jq -r '.txs[] | \"üìã Hash: \\(.txhash)\\nüìä Height: \\(.height)\\n‚è∞ Time: \\(.timestamp)\\n---\"'\n    fi\nelse\n    echo \"‚ÑπÔ∏è  No recent transactions found\"\nfi\n\necho \"==============================\"\nEOF\n\nchmod +x $HOME/wallet_info.sh\n\n# Run wallet info\n./wallet_info.sh\n```\n\n## üîê Security Best Practices\n\n```bash\n# Backup wallet keys\necho \"üíæ Creating wallet backup...\"\nmkdir -p $HOME/wallet_backup\n\n# Backup keyring (if using file keyring)\nif [ -d \"$HOME/.story/story/keyring-test\" ]; then\n    cp -r $HOME/.story/story/keyring-test $HOME/wallet_backup/\n    echo \"‚úÖ Keyring backed up\"\nfi\n\n# Export mnemonic (if available)\necho \"üîë To backup your mnemonic, use:\"\necho \"story keys export validator --keyring-backend test\"\necho \"‚ö†Ô∏è  Keep your mnemonic safe and never share it!\"\n\n# Set secure permissions\nchmod 700 $HOME/wallet_backup\necho \"üîí Secure permissions set on backup directory\"\n```\n\n## üö® Emergency Wallet Recovery\n\n```bash\n# Wallet recovery script\ncat > $HOME/wallet_recovery.sh << 'EOF'\n#!/bin/bash\n\necho \"üö® Wallet Recovery Assistant\"\necho \"============================\"\n\n# Check if wallet exists\nWALLET_EXISTS=$(story keys list --keyring-backend test 2>/dev/null | grep -c \"validator\")\n\nif [ \"$WALLET_EXISTS\" -gt 0 ]; then\n    echo \"‚úÖ Wallet 'validator' found\"\n    story keys show validator --keyring-backend test\nelse\n    echo \"‚ùå Wallet 'validator' not found\"\n    echo \"\\nüîß Recovery options:\"\n    echo \"1. Restore from mnemonic: story keys add validator --recover --keyring-backend test\"\n    echo \"2. Import from backup: Copy keyring files to ~/.story/story/keyring-test/\"\n    echo \"3. Create new wallet: story keys add validator --keyring-backend test\"\nfi\n\n# Check keyring directory\necho \"\\nüìÅ Keyring Directory Status:\"\nif [ -d \"$HOME/.story/story/keyring-test\" ]; then\n    echo \"‚úÖ Keyring directory exists\"\n    ls -la $HOME/.story/story/keyring-test/\nelse\n    echo \"‚ùå Keyring directory missing\"\n    echo \"üí° Create with: mkdir -p $HOME/.story/story/keyring-test\"\nfi\n\necho \"============================\"\nEOF\n\nchmod +x $HOME/wallet_recovery.sh\n```\n\n:::warning\n**Wallet Security Warning:**\n- Never share your private keys or mnemonic\n- Always backup your wallet before any operations\n- Use secure, offline storage for backups\n- Test recovery procedures with small amounts first\n- Keep multiple backup copies in different locations\n:::"
        }
      ]
    },
    {
      "id": "upgrades-maintenance",
      "title": "Upgrades & Maintenance",
      "icon": "üîÑ",
      "type": "section",
      "children": [
        {
          "id": "upgrade-announcements",
          "title": "Upgrade Announcements",
          "icon": "üì°",
          "type": "page",
          "content": "# üì° Where to Follow Upgrade Announcements\n\n## 1. **Official GitHub Releases** (Primary Source)\n\n| Repository | Purpose | Link |\n|------------|---------|------|\n| **Story Consensus Client** | Main blockchain client | [https://github.com/piplabs/story/releases](https://github.com/piplabs/story/releases) |\n| **Story-Geth Execution Client** | Ethereum execution layer | [https://github.com/piplabs/story-geth/releases](https://github.com/piplabs/story-geth/releases) |\n\n## 2. **Official Documentation**\n\n| Resource | Purpose | Link |\n|----------|---------|------|\n| **Release Notes** | Detailed upgrade information | [https://docs.story.foundation/network/releases](https://docs.story.foundation/network/releases) |\n| **Node Upgrade Guide** | Step-by-step upgrade instructions | [https://docs.story.foundation/network/operate/upgrade](https://docs.story.foundation/network/operate/upgrade) |\n\n## 3. **Community Channels**\n\n| Platform | Purpose | Link |\n|----------|---------|------|\n| **Discord** | Real-time announcements | [https://discord.gg/storyprotocol](https://discord.gg/storyprotocol) |\n| **Telegram** | Official announcements | [https://t.me/storyprotocol](https://t.me/storyprotocol) |\n| **Twitter/X** | Public announcements | [@Story_Protocol](https://twitter.com/Story_Protocol) |\n\n## üîî Upgrade Types and Urgency\n\n| Type | Description | Action Required | Timeline |\n|------|-------------|-----------------|----------|\n| **Major** | Hard fork upgrade with block height | **MANDATORY** before block height | Usually 1-2 weeks notice |\n| **Minor** | Bug fixes, improvements | **RECOMMENDED** ASAP | Deploy within 24-48 hours |\n| **Critical** | Security fixes | **URGENT** | Deploy immediately |\n| **Optional** | Performance improvements | Optional | Deploy when convenient |\n\n## üìß Setting Up Notifications\n\n### GitHub Watch Notifications\n```bash\n# Watch Story repositories for releases\necho \"üìß Setup GitHub notifications:\"\necho \"1. Go to https://github.com/piplabs/story\"\necho \"2. Click 'Watch' ‚Üí 'Custom' ‚Üí 'Releases'\"\necho \"3. Repeat for https://github.com/piplabs/story-geth\"\n```\n\n### Discord Notification Setup\n```bash\necho \"üîî Discord Setup:\"\necho \"1. Join: https://discord.gg/storyprotocol\"\necho \"2. Navigate to #announcements channel\"\necho \"3. Right-click channel ‚Üí Notification Settings ‚Üí All Messages\"\n```\n\n### RSS/Feed Monitoring\n```bash\n# RSS feeds for automated monitoring\necho \"üì° RSS Feeds for monitoring:\"\necho \"Story Releases: https://github.com/piplabs/story/releases.atom\"\necho \"Story-Geth Releases: https://github.com/piplabs/story-geth/releases.atom\"\n```\n\n## üö® Emergency Upgrade Notifications\n\n```bash\n# Create upgrade monitoring script\ncat > $HOME/upgrade_monitor.sh << 'EOF'\n#!/bin/bash\n\necho \"üîç Checking for Story Protocol Upgrades\"\necho \"=======================================\"\n\n# Check Story releases\necho \"üì¶ Checking Story releases...\"\nLATEST_STORY=$(curl -s https://api.github.com/repos/piplabs/story/releases/latest | jq -r '.tag_name')\nCURRENT_STORY=$(story version 2>/dev/null | grep -oE 'v[0-9]+\\.[0-9]+\\.[0-9]+' || echo \"unknown\")\n\necho \"Current Story version: $CURRENT_STORY\"\necho \"Latest Story version: $LATEST_STORY\"\n\nif [ \"$CURRENT_STORY\" != \"$LATEST_STORY\" ] && [ \"$LATEST_STORY\" != \"null\" ]; then\n    echo \"‚ö†Ô∏è  NEW STORY VERSION AVAILABLE: $LATEST_STORY\"\nelse\n    echo \"‚úÖ Story is up to date\"\nfi\n\n# Check Story-Geth releases\necho \"\\n‚ö° Checking Story-Geth releases...\"\nLATEST_GETH=$(curl -s https://api.github.com/repos/piplabs/story-geth/releases/latest | jq -r '.tag_name')\nCURRENT_GETH=$(story-geth version 2>/dev/null | grep -oE 'v[0-9]+\\.[0-9]+\\.[0-9]+' | head -1 || echo \"unknown\")\n\necho \"Current Geth version: $CURRENT_GETH\"\necho \"Latest Geth version: $LATEST_GETH\"\n\nif [ \"$CURRENT_GETH\" != \"$LATEST_GETH\" ] && [ \"$LATEST_GETH\" != \"null\" ]; then\n    echo \"‚ö†Ô∏è  NEW STORY-GETH VERSION AVAILABLE: $LATEST_GETH\"\nelse\n    echo \"‚úÖ Story-Geth is up to date\"\nfi\n\n# Check for governance proposals (upgrades)\necho \"\\nüèõÔ∏è  Checking governance proposals...\"\nPROPOSALS=$(curl -s \"https://aeneid.storyrpc.io/cosmos/gov/v1beta1/proposals?proposal_status=2\" 2>/dev/null | jq '.proposals | length' 2>/dev/null || echo \"0\")\n\nif [ \"$PROPOSALS\" -gt 0 ]; then\n    echo \"üìã Active governance proposals: $PROPOSALS\"\n    echo \"üîç Check: https://aeneid.storyscan.io/governance\"\nelse\n    echo \"‚úÖ No active governance proposals\"\nfi\n\necho \"=======================================\"\necho \"‚è∞ Last checked: $(date)\"\nEOF\n\nchmod +x $HOME/upgrade_monitor.sh\n\n# Run upgrade monitor\n./upgrade_monitor.sh\n```\n\n## üìÖ Upgrade Preparation Checklist\n\n```bash\n# Create upgrade preparation checklist\ncat > $HOME/upgrade_checklist.sh << 'EOF'\n#!/bin/bash\n\necho \"üìã Pre-Upgrade Checklist\"\necho \"========================\"\n\n# Check node health\necho \"üè• 1. Node Health Check:\"\nif systemctl is-active story >/dev/null && systemctl is-active story-geth >/dev/null; then\n    echo \"‚úÖ Services are running\"\nelse\n    echo \"‚ùå Services not running properly\"\nfi\n\n# Check sync status\necho \"\\nüîÑ 2. Sync Status Check:\"\nCATCHING_UP=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.catching_up' 2>/dev/null)\nif [ \"$CATCHING_UP\" = \"false\" ]; then\n    echo \"‚úÖ Node is fully synced\"\nelse\n    echo \"‚ùå Node is still syncing\"\nfi\n\n# Check disk space\necho \"\\nüíæ 3. Disk Space Check:\"\nDISK_USAGE=$(df -h $HOME/.story | awk 'NR==2 {print $5}' | tr -d '%')\nif [ \"$DISK_USAGE\" -lt 80 ]; then\n    echo \"‚úÖ Sufficient disk space ($DISK_USAGE% used)\"\nelse\n    echo \"‚ö†Ô∏è  High disk usage ($DISK_USAGE% used)\"\nfi\n\n# Check backups\necho \"\\nüíæ 4. Backup Check:\"\nif [ -f \"$HOME/validator_backup/priv_validator_key.json\" ]; then\n    echo \"‚úÖ Validator key backup exists\"\nelse\n    echo \"‚ùå Validator key backup missing\"\nfi\n\n# Check cosmovisor setup\necho \"\\nüîÑ 5. Cosmovisor Check:\"\nif [ -f \"$HOME/.story/story/cosmovisor/current/bin/story\" ]; then\n    echo \"‚úÖ Cosmovisor is properly configured\"\nelse\n    echo \"‚ùå Cosmovisor setup incomplete\"\nfi\n\n# Check environment variables\necho \"\\nüåê 6. Environment Variables:\"\nif [ -n \"$DAEMON_NAME\" ] && [ -n \"$DAEMON_HOME\" ]; then\n    echo \"‚úÖ Cosmovisor environment variables set\"\nelse\n    echo \"‚ùå Missing environment variables\"\nfi\n\necho \"========================\"\necho \"üìÖ Ready for upgrade: $(date)\"\nEOF\n\nchmod +x $HOME/upgrade_checklist.sh\n```\n\n## üîî Automated Alert System\n\n```bash\n# Setup automated upgrade alerts\ncat > $HOME/setup_alerts.sh << 'EOF'\n#!/bin/bash\n\necho \"üîî Setting up Upgrade Alerts\"\necho \"============================\"\n\n# Create upgrade alert script\ncat > $HOME/upgrade_alert.sh << 'ALERT_EOF'\n#!/bin/bash\n\n# Check for new releases\nSTORY_LATEST=$(curl -s https://api.github.com/repos/piplabs/story/releases/latest | jq -r '.tag_name')\nGETH_LATEST=$(curl -s https://api.github.com/repos/piplabs/story-geth/releases/latest | jq -r '.tag_name')\n\n# Store current versions\nVERSION_FILE=\"$HOME/.story_versions\"\nif [ ! -f \"$VERSION_FILE\" ]; then\n    echo \"STORY_VERSION=unknown\" > \"$VERSION_FILE\"\n    echo \"GETH_VERSION=unknown\" >> \"$VERSION_FILE\"\nfi\n\nsource \"$VERSION_FILE\"\n\n# Check if versions changed\nif [ \"$STORY_VERSION\" != \"$STORY_LATEST\" ]; then\n    echo \"üö® NEW STORY VERSION: $STORY_LATEST (was: $STORY_VERSION)\" | logger -t story-upgrade\n    echo \"STORY_VERSION=$STORY_LATEST\" > \"$VERSION_FILE\"\n    echo \"GETH_VERSION=$GETH_VERSION\" >> \"$VERSION_FILE\"\nfi\n\nif [ \"$GETH_VERSION\" != \"$GETH_LATEST\" ]; then\n    echo \"üö® NEW GETH VERSION: $GETH_LATEST (was: $GETH_VERSION)\" | logger -t story-upgrade\n    sed -i \"s/GETH_VERSION=.*/GETH_VERSION=$GETH_LATEST/\" \"$VERSION_FILE\"\nfi\nALERT_EOF\n\nchmod +x $HOME/upgrade_alert.sh\n\n# Add to crontab (check every hour)\n(crontab -l 2>/dev/null; echo \"0 * * * * $HOME/upgrade_alert.sh\") | crontab -\n\necho \"‚úÖ Upgrade alerts configured\"\necho \"üìß Alerts will be logged to system journal\"\necho \"üîç View alerts with: journalctl -t story-upgrade\"\necho \"============================\"\nEOF\n\nchmod +x $HOME/setup_alerts.sh\n```\n\n:::tip\n**Upgrade Best Practices:**\n\n1. **Monitor Official Channels**: Always follow official GitHub releases\n2. **Test Environment**: Test upgrades on testnets first if possible\n3. **Backup Everything**: Always backup before upgrades\n4. **Scheduled Maintenance**: Plan upgrades during low-activity periods\n5. **Monitor Network**: Watch network consensus during upgrades\n6. **Have Rollback Plan**: Know how to rollback if issues occur\n:::"
        },
        {
          "id": "upgrade-methods",
          "title": "Upgrade Methods",
          "icon": "üîß",
          "type": "page",
          "content": "# üîß Upgrade Methods\n\n## ‚ö†Ô∏è **Important: Why Build from Source?**\n\n**Pre-compiled binaries on GitHub are built with Ubuntu 24.04** and may not work properly on Ubuntu 22.04 due to library dependencies. **Building from source ensures compatibility** with your system.\n\n### ‚ùå **Pre-compiled Binaries Issue**\n- Built for Ubuntu 24.04\n- Different glibc versions\n- Library dependency conflicts\n- May cause crashes or failures\n\n### ‚úÖ **Build from Source (Required for Ubuntu 22.04)**\n- **Full compatibility** with your system\n- **Correct library linking**\n- **Stable operation**\n- **No dependency issues**\n\n## üöÄ Method 1: Cosmovisor Auto-Upgrade (Recommended)\n\n```bash\n# Get the latest release tag\nLATEST_VERSION=$(curl -s https://api.github.com/repos/piplabs/story/releases/latest | jq -r '.tag_name')\necho \"Latest version: $LATEST_VERSION\"\n\n# ‚ö†Ô∏è IMPORTANT: Set the upgrade height from official announcement\nUPGRADE_HEIGHT=\"REPLACE_WITH_ACTUAL_HEIGHT\"  # Example: 2065886\n\necho \"‚ö†Ô∏è CRITICAL: Replace UPGRADE_HEIGHT with actual height from announcement!\"\necho \"üì° Check official channels for upgrade height\"\n\n# Validate upgrade height is set\nif [ \"$UPGRADE_HEIGHT\" = \"REPLACE_WITH_ACTUAL_HEIGHT\" ]; then\n    echo \"‚ùå ERROR: You must set the actual upgrade height!\"\n    echo \"üìã Current height: $(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\"\n    exit 1\nfi\n\n# Clone and build the new version\ncd $HOME\nrm -rf story-upgrade\ngit clone https://github.com/piplabs/story story-upgrade\ncd story-upgrade\ngit checkout $LATEST_VERSION\ngo build -o story ./client\n\n# Verify the build\n./story version\n\n# Create upgrade folder\nmkdir -p $HOME/.story/story/cosmovisor/upgrades/$LATEST_VERSION/bin\n\n# Copy built binary to upgrade directory\ncp ./story $HOME/.story/story/cosmovisor/upgrades/$LATEST_VERSION/bin/\n\n# Create upgrade info\necho \"{\\\"name\\\":\\\"$LATEST_VERSION\\\",\\\"time\\\":\\\"0001-01-01T00:00:00Z\\\",\\\"height\\\":$UPGRADE_HEIGHT}\" > $HOME/.story/story/cosmovisor/upgrades/$LATEST_VERSION/upgrade-info.json\n\n# Setup automatic upgrade with Cosmovisor\ncosmovisor add-upgrade $LATEST_VERSION $HOME/.story/story/cosmovisor/upgrades/$LATEST_VERSION/bin/story --force --upgrade-height $UPGRADE_HEIGHT\n\n# Verify setup\necho \"‚úÖ Checking upgrade setup:\"\nls -l $HOME/.story/story/cosmovisor/current\ncat $HOME/.story/story/cosmovisor/upgrades/$LATEST_VERSION/upgrade-info.json\n\n# Show status\nCURRENT_HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\nBLOCKS_REMAINING=$((UPGRADE_HEIGHT - CURRENT_HEIGHT))\necho \"üìä Current Height: $CURRENT_HEIGHT\"\necho \"üéØ Upgrade Height: $UPGRADE_HEIGHT\"  \necho \"‚è≥ Blocks Remaining: $BLOCKS_REMAINING\"\n\necho \"‚úÖ Automatic upgrade scheduled! Monitor with:\"\necho \"sudo journalctl -u story -f\"\n\n# Cleanup\nrm -rf $HOME/story-upgrade\n```\n\n## üîß Method 2: Manual Build and Replace (Advanced Users)\n\n```bash\n# Stop the service\nsudo systemctl stop story\n\n# Get the latest release tag and build\nLATEST_VERSION=$(curl -s https://api.github.com/repos/piplabs/story/releases/latest | jq -r '.tag_name')\necho \"Building version: $LATEST_VERSION\"\n\ncd $HOME\nrm -rf story-upgrade\ngit clone https://github.com/piplabs/story story-upgrade\ncd story-upgrade\ngit checkout $LATEST_VERSION\ngo build -o story ./client\n\n# Replace the main binary\nsudo mv story $HOME/go/bin/story\nsudo chmod +x $HOME/go/bin/story\n\n# Update cosmovisor current binary\ncosmovisor init $(which story)\n\n# Verify version\nstory version\n\n# Start the service\nsudo systemctl start story\n\n# Check if upgrade was successful\nsudo journalctl -u story -n 50 --no-pager\n\n# Cleanup\ncd $HOME\nrm -rf story-upgrade\n```\n\n## ‚ö° Method 3: Story-Geth Upgrade\n\n```bash\n# Stop story-geth service\nsudo systemctl stop story-geth\n\n# Get latest story-geth version\nLATEST_GETH_VERSION=$(curl -s https://api.github.com/repos/piplabs/story-geth/releases/latest | jq -r '.tag_name')\necho \"Building Story-Geth version: $LATEST_GETH_VERSION\"\n\n# Clone and build\ncd $HOME\nrm -rf story-geth-upgrade\ngit clone https://github.com/piplabs/story-geth.git story-geth-upgrade\ncd story-geth-upgrade\ngit checkout $LATEST_GETH_VERSION\ngo build -v ./cmd/geth\n\n# Replace binary\nmv ./geth $HOME/go/bin/story-geth\nchmod +x $HOME/go/bin/story-geth\n\n# Verify version\nstory-geth version\n\n# Start service\nsudo systemctl start story-geth\n\n# Wait and start story\nsleep 10\nsudo systemctl start story\n\n# Cleanup\ncd $HOME\nrm -rf story-geth-upgrade\n```\n\n## üîç Upgrade Verification\n\n```bash\n# Create upgrade verification script\ncat > $HOME/verify_upgrade.sh << 'EOF'\n#!/bin/bash\n\necho \"üîç Upgrade Verification\"\necho \"======================\"\n\n# Check binary versions\necho \"üì¶ Binary Versions:\"\necho \"Story: $(story version 2>/dev/null || echo 'Error getting version')\"\necho \"Story-Geth: $(story-geth version 2>/dev/null | head -1 || echo 'Error getting version')\"\necho \"Cosmovisor: $(cosmovisor version 2>/dev/null || echo 'Error getting version')\"\n\n# Check service status\necho \"\\nüîß Service Status:\"\nSTORY_STATUS=$(systemctl is-active story)\nGETH_STATUS=$(systemctl is-active story-geth)\necho \"Story: $STORY_STATUS\"\necho \"Story-Geth: $GETH_STATUS\"\n\n# Check node connectivity\necho \"\\nüåê Node Connectivity:\"\nif curl -s --max-time 5 localhost:${STORY_PORT}657/status >/dev/null; then\n    HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\n    CATCHING_UP=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.catching_up')\n    PEERS=$(curl -s localhost:${STORY_PORT}657/net_info | jq -r '.result.n_peers')\n    \n    echo \"‚úÖ RPC responsive\"\n    echo \"üìä Height: $HEIGHT\"\n    echo \"üîÑ Catching up: $CATCHING_UP\"\n    echo \"üë• Peers: $PEERS\"\nelse\n    echo \"‚ùå RPC not responding\"\nfi\n\n# Check for errors in logs\necho \"\\n‚ö†Ô∏è  Recent Errors:\"\necho \"Story errors (last 5 minutes):\"\nsudo journalctl -u story --since \"5 minutes ago\" | grep -i \"error\\|fail\\|panic\" | tail -3\necho \"\\nGeth errors (last 5 minutes):\"\nsudo journalctl -u story-geth --since \"5 minutes ago\" | grep -i \"error\\|fail\\|panic\" | tail -3\n\necho \"======================\"\nEOF\n\nchmod +x $HOME/verify_upgrade.sh\n\n# Run verification\n./verify_upgrade.sh\n```\n\n## üîÑ Rollback Procedure\n\n```bash\n# Create rollback script for emergencies\ncat > $HOME/rollback_upgrade.sh << 'EOF'\n#!/bin/bash\n\necho \"üîÑ Emergency Rollback Procedure\"\necho \"===============================\"\n\necho \"‚ö†Ô∏è  WARNING: This will rollback to the previous version!\"\nread -p \"Continue? (y/N): \" confirm\n\nif [ \"$confirm\" != \"y\" ] && [ \"$confirm\" != \"Y\" ]; then\n    echo \"Rollback cancelled\"\n    exit 0\nfi\n\n# Stop services\necho \"üõë Stopping services...\"\nsudo systemctl stop story story-geth\n\n# Check cosmovisor backups\necho \"üìÅ Checking available versions...\"\nls -la $HOME/.story/story/cosmovisor/\n\n# Rollback to genesis version\necho \"üîÑ Rolling back to genesis version...\"\nrm -f $HOME/.story/story/cosmovisor/current\nln -s $HOME/.story/story/cosmovisor/genesis $HOME/.story/story/cosmovisor/current\n\n# Verify rollback\necho \"‚úÖ Rollback status:\"\nls -la $HOME/.story/story/cosmovisor/current\n\n# Restart services\necho \"üöÄ Restarting services...\"\nsudo systemctl start story-geth\nsleep 10\nsudo systemctl start story\n\n# Verify\necho \"üìä Post-rollback status:\"\nsudo systemctl status story story-geth --no-pager\n\necho \"===============================\"\necho \"üîÑ Rollback completed\"\nEOF\n\nchmod +x $HOME/rollback_upgrade.sh\n```\n\n## üìä Upgrade Monitoring\n\n```bash\n# Create upgrade monitoring script\ncat > $HOME/upgrade_monitor_detailed.sh << 'EOF'\n#!/bin/bash\n\necho \"üìä Upgrade Progress Monitor\"\necho \"============================\"\n\nwhile true; do\n    clear\n    echo \"üìÖ $(date)\"\n    echo \"============================\"\n    \n    # Current height and upgrade info\n    CURRENT_HEIGHT=$(curl -s localhost:${STORY_PORT}657/status 2>/dev/null | jq -r '.result.sync_info.latest_block_height' 2>/dev/null || echo \"N/A\")\n    CATCHING_UP=$(curl -s localhost:${STORY_PORT}657/status 2>/dev/null | jq -r '.result.sync_info.catching_up' 2>/dev/null || echo \"N/A\")\n    \n    echo \"üìä Current Height: $CURRENT_HEIGHT\"\n    echo \"üîÑ Catching Up: $CATCHING_UP\"\n    \n    # Check for pending upgrades\n    if [ -d \"$HOME/.story/story/cosmovisor/upgrades\" ]; then\n        echo \"\\nüîÆ Pending Upgrades:\"\n        for upgrade in $HOME/.story/story/cosmovisor/upgrades/*/; do\n            if [ -d \"$upgrade\" ]; then\n                upgrade_name=$(basename \"$upgrade\")\n                if [ -f \"$upgrade/upgrade-info.json\" ]; then\n                    upgrade_height=$(cat \"$upgrade/upgrade-info.json\" | jq -r '.height')\n                    echo \"üìã $upgrade_name at height $upgrade_height\"\n                    \n                    if [[ \"$CURRENT_HEIGHT\" =~ ^[0-9]+$ ]] && [[ \"$upgrade_height\" =~ ^[0-9]+$ ]]; then\n                        blocks_remaining=$((upgrade_height - CURRENT_HEIGHT))\n                        echo \"‚è≥ Blocks remaining: $blocks_remaining\"\n                    fi\n                fi\n            fi\n        done\n    fi\n    \n    # Service status\n    echo \"\\nüîß Service Status:\"\n    systemctl is-active story >/dev/null && echo \"‚úÖ Story: Active\" || echo \"‚ùå Story: Inactive\"\n    systemctl is-active story-geth >/dev/null && echo \"‚úÖ Story-Geth: Active\" || echo \"‚ùå Story-Geth: Inactive\"\n    \n    echo \"\\n============================\"\n    echo \"Press Ctrl+C to exit\"\n    sleep 10\ndone\nEOF\n\nchmod +x $HOME/upgrade_monitor_detailed.sh\n```\n\n:::warning\n**Upgrade Safety Guidelines:**\n\n1. **Always Backup**: Create full backups before any upgrade\n2. **Test Environment**: Test upgrades on non-production nodes first\n3. **Monitor Consensus**: Watch network consensus during upgrades\n4. **Have Rollback Plan**: Know how to quickly rollback if needed\n5. **Community Coordination**: Coordinate with other validators\n6. **Monitor Logs**: Watch logs carefully during upgrade process\n:::"
        }
      ]
    },
    {
      "id": "troubleshooting",
      "title": "Troubleshooting",
      "icon": "üîç",
      "type": "section",
      "children": [
        {
          "id": "common-issues",
          "title": "Common Issues",
          "icon": "üö®",
          "type": "page",
          "content": "# üö® Common Issues and Solutions\n\nThis section covers the most frequently encountered issues and their step-by-step solutions.\n\n## üîß Node Not Syncing\n\n### Symptoms\n- Node stuck at same block height\n- `catching_up: true` for extended periods\n- No new blocks being processed\n\n### Solutions\n\n```bash\n# 1. Check current sync status\ncurl localhost:${STORY_PORT}657/status | jq '.result.sync_info'\n\n# 2. Check peer connections\nPEER_COUNT=$(curl -s localhost:${STORY_PORT}657/net_info | jq '.result.n_peers')\necho \"Connected peers: $PEER_COUNT\"\n\nif [ \"$PEER_COUNT\" -lt 5 ]; then\n    echo \"‚ö†Ô∏è  Low peer count. Getting fresh peers...\"\n    ./get_fresh_peers.sh\nfi\n\n# 3. Check if geth is syncing\nstory-geth --exec \"eth.syncing\" attach ~/.story/geth/aeneid/geth.ipc\n\n# 4        {
          "id": "coinsspor-snapshots",
          "title": "Coinsspor Advanced Snapshots",
          "icon": "üì∏",
          "type": "page",
          "content": "# üì∏ Coinsspor Advanced Snapshot Service\n\n**Next-generation snapshot service with ZSTD compression and aria2c multi-connection downloads**\n\n- üîÑ **Updated**: Every 6 hours (00:00, 06:00, 12:00, 18:00 UTC)\n- üóúÔ∏è **Compression**: ZSTD format (superior to LZ4)\n- ‚ö° **Download Tool**: aria2c multi-connection\n- üîí **Security**: SSL secured with validator-safe backup/restore\n- üíæ **Size**: ~36GB Consensus + ~15GB Execution (optimized compression)\n\n## üõ†Ô∏è Prerequisites Installation\n\n**Install required packages first:**\n\n```bash\n# Ubuntu/Debian\nsudo apt update\nsudo apt install -y aria2 zstd jq curl\n\n# CentOS/RHEL/Fedora\nsudo yum install -y aria2 zstd jq curl\n# or\nsudo dnf install -y aria2 zstd jq curl\n\n# Verify installation\naria2c --version\nzstd --version\n```\n\n## üìä Check Latest Snapshot Status\n\n```bash\n# Get current snapshot height\necho \"Coinsspor Snapshot Height: $(curl -s https://snaps.coinsspor.com/story/aeneid/coinsspor-height.txt)\"\n\n# Get detailed snapshot information\ncurl -s https://snaps.coinsspor.com/story/aeneid/coinsspor-info.json | jq '.'\n```\n\n## üöÄ Advanced Download Script\n\n```bash\n#!/bin/bash\n\n# Coinsspor Advanced Snapshot Download - Server Optimized\n# Using aria2c + ZSTD for maximum performance\n\nset -e\n\necho \"üåü Coinsspor Advanced Snapshot Download (Server Optimized)\"\necho \"=========================================================\"\n\n# Configuration\nCOINSSPOR_BASE=\"https://snaps.coinsspor.com/story/aeneid\"\nSTORY_DATA=\"$HOME/.story\"\nTEMP_DIR=\"/tmp/coinsspor_sync\"\n\n# Enhanced Story RPC port detection with connectivity test\ndetect_story_port() {\n    local config_file=\"$STORY_DATA/story/config/config.toml\"\n    \n    # Primary method: Test common Story ports with connectivity (fast & reliable)\n    for test_port in 16657 26657 27657; do\n        if timeout 2 curl -s \"localhost:$test_port/status\" >/dev/null 2>&1; then\n            echo \"$test_port\"\n            return\n        fi\n    done\n    \n    # Backup method: Extract from config if available\n    if [[ -f \"$config_file\" ]]; then\n        local extracted_port=$(grep \"laddr.*tcp\" \"$config_file\" | grep -oE \":[0-9]+\" | tr -d ':' | head -1)\n        if [[ -n \"$extracted_port\" ]] && [[ \"$extracted_port\" =~ ^[0-9]+$ ]]; then\n            if timeout 2 curl -s \"localhost:$extracted_port/status\" >/dev/null 2>&1; then\n                echo \"$extracted_port\"\n                return\n            fi\n        fi\n    fi\n    \n    # Final fallback\n    echo \"26657\"\n}\n\nSTORY_PORT=$(detect_story_port)\nLOCAL_RPC=\"localhost:$STORY_PORT\"\n\necho \"üì¶ Checking dependencies...\"\nfor cmd in aria2c zstd jq; do\n    if ! command -v $cmd &> /dev/null; then\n        echo \"‚ùå Missing dependency: $cmd\"\n        echo \"üí° Install with: sudo apt install aria2 zstd jq\"\n        exit 1\n    fi\ndone\necho \"‚úÖ All dependencies ready\"\n\n# Discover snapshots via JSON API\necho \"üîç Discovering latest snapshots...\"\nMETADATA=$(curl -s \"$COINSSPOR_BASE/coinsspor-info.json\")\nCONSENSUS_FILE=$(echo \"$METADATA\" | jq -r '.snapshots.consensus')\nEXECUTION_FILE=$(echo \"$METADATA\" | jq -r '.snapshots.execution')\nBLOCK_HEIGHT=$(echo \"$METADATA\" | jq -r '.block_height')\n\nif [ \"$CONSENSUS_FILE\" = \"null\" ] || [ \"$EXECUTION_FILE\" = \"null\" ]; then\n    echo \"‚ùå Could not discover snapshot files\"\n    exit 1\nfi\n\necho \"üìä Snapshot Information:\"\necho \"  Block Height: $BLOCK_HEIGHT\"\necho \"  Consensus: $CONSENSUS_FILE\"\necho \"  Execution: $EXECUTION_FILE\"\necho \"  Detected RPC Port: $STORY_PORT\"\n\n# Confirmation\nread -p \"üöÄ Continue with download? (y/N): \" -n 1 -r\necho\nif [[ ! $REPLY =~ ^[Yy]$ ]]; then\n    echo \"Download cancelled\"\n    exit 0\nfi\n\n# Prepare environment\nmkdir -p \"$TEMP_DIR\"\n\necho \"üõë Stopping services...\"\nsudo systemctl stop story story-geth\n\necho \"üíæ Backing up validator state...\"\nif [[ -f \"$STORY_DATA/story/data/priv_validator_state.json\" ]]; then\n    cp \"$STORY_DATA/story/data/priv_validator_state.json\" \"$TEMP_DIR/validator_backup.json\"\n    echo \"‚úÖ Validator state backed up\"\nfi\n\necho \"üßπ Cleaning target directories...\"\nrm -rf \"$STORY_DATA/story/data\"\nrm -rf \"$STORY_DATA/geth/aeneid/geth/chaindata\"\nmkdir -p \"$STORY_DATA/geth/aeneid/geth\"\n\necho \"\"\necho \"üì• Downloading with optimized aria2c settings...\"\n\n# SERVER OPTIMIZED aria2c configuration\nARIA2C_OPTIONS=(\n    --max-connection-per-server=12\n    --split=12\n    --min-split-size=15M\n    --max-concurrent-downloads=2\n    --disk-cache=64M\n    --file-allocation=falloc\n    --continue=true\n    --max-tries=5\n    --retry-wait=2\n    --timeout=90\n    --connect-timeout=20\n    --lowest-speed-limit=400K\n    --user-agent=\"Coinsspor-Client/3.0-Fast\"\n)\n\n# Download consensus\necho \"üîπ Downloading consensus snapshot...\"\naria2c \"${ARIA2C_OPTIONS[@]}\" \\\n    --dir=\"$TEMP_DIR\" \\\n    --out=\"$CONSENSUS_FILE\" \\\n    \"$COINSSPOR_BASE/$CONSENSUS_FILE\"\n\n# Download execution\necho \"üî∏ Downloading execution snapshot...\"\naria2c \"${ARIA2C_OPTIONS[@]}\" \\\n    --dir=\"$TEMP_DIR\" \\\n    --out=\"$EXECUTION_FILE\" \\\n    \"$COINSSPOR_BASE/$EXECUTION_FILE\"\n\necho \"\"\necho \"üìÇ Extracting with ZSTD compression...\"\n\n# Extract consensus\necho \"üîπ Extracting consensus snapshot...\"\nif ! zstd -d --stdout \"$TEMP_DIR/$CONSENSUS_FILE\" | tar -xf - -C \"$STORY_DATA/story\"; then\n    echo \"‚ùå Error extracting consensus snapshot\"\n    exit 1\nfi\n\n# Extract execution\necho \"üî∏ Extracting execution snapshot...\"\nif ! zstd -d --stdout \"$TEMP_DIR/$EXECUTION_FILE\" | tar -xf - -C \"$STORY_DATA/geth/aeneid/geth\"; then\n    echo \"‚ùå Error extracting execution snapshot\"\n    exit 1\nfi\n\necho \"üîÑ Restoring validator state...\"\nif [[ -f \"$TEMP_DIR/validator_backup.json\" ]]; then\n    cp \"$TEMP_DIR/validator_backup.json\" \"$STORY_DATA/story/data/priv_validator_state.json\"\n    echo \"‚úÖ Validator state restored\"\nfi\n\necho \"üöÄ Starting services...\"\nsudo systemctl start story-geth\nsleep 10\nsudo systemctl start story\n\necho \"üßπ Cleaning up temporary files...\"\nrm -rf \"$TEMP_DIR\"\n\necho \"\"\necho \"‚úÖ Coinsspor snapshot download completed successfully!\"\necho \"üìä Monitor sync with: sudo journalctl -u story -u story-geth -f\"\n\n# Enhanced final status\necho \"\"\necho \"üéØ Final Status Check:\"\nsleep 5\n\nif timeout 5 curl -s \"$LOCAL_RPC/status\" >/dev/null 2>&1; then\n    LOCAL_HEIGHT=$(curl -s \"$LOCAL_RPC/status\" 2>/dev/null | jq -r '.result.sync_info.latest_block_height' 2>/dev/null || echo \"Unknown\")\n    CATCHING_UP=$(curl -s \"$LOCAL_RPC/status\" 2>/dev/null | jq -r '.result.sync_info.catching_up' 2>/dev/null || echo \"unknown\")\n    \n    echo \"üìà Node Status:\"\n    echo \"  ‚Ä¢ RPC Port: $STORY_PORT ‚úÖ\"\n    echo \"  ‚Ä¢ Current Height: $LOCAL_HEIGHT\"\n    echo \"  ‚Ä¢ Target Height: $BLOCK_HEIGHT\"\n    echo \"  ‚Ä¢ Catching Up: $CATCHING_UP\"\n    \n    if [[ \"$LOCAL_HEIGHT\" =~ ^[0-9]+$ ]] && [[ \"$BLOCK_HEIGHT\" =~ ^[0-9]+$ ]]; then\n        blocks_behind=$((BLOCK_HEIGHT - LOCAL_HEIGHT))\n        if [[ $blocks_behind -lt 100 ]]; then\n            echo \"  ‚Ä¢ Status: üéâ Nearly synced! ($blocks_behind blocks behind)\"\n        else\n            echo \"  ‚Ä¢ Status: üîÑ Syncing... ($blocks_behind blocks behind)\"\n        fi\n    fi\nelse\n    echo \"‚ö†Ô∏è  Could not connect to RPC on port $STORY_PORT\"\n    echo \"   Node may still be starting up.\"\nfi\n\necho \"\"\necho \"üåü Snapshot installation completed! Happy validating! üöÄ\"\n```\n\n## üìä Service Information\n\n| Feature | Details |\n|---------|----------|\n| **URL** | https://snaps.coinsspor.com/story/aeneid/ |\n| **API Endpoint** | `coinsspor-info.json` |\n| **Update Frequency** | Every 6 hours |\n| **Compression** | ZSTD (superior to LZ4) |\n| **Download Tool** | aria2c multi-connection |\n| **File Format** | `coinsspor-aeneid-TYPE-HEIGHT-DATE.tar.zst` |\n| **Security** | Validator state preservation |\n| **SSL** | ‚úÖ HTTPS secured |\n\n## ‚ö° Performance Benefits\n\n- **üöÄ Ultra-Fast Downloads**: aria2c with 12 parallel connections (~270MB/s)\n- **üóúÔ∏è Superior Compression**: ZSTD provides better compression than LZ4\n- **üíæ Optimized Size**: ~51GB total (vs ~200GB+ full node)\n- **‚è±Ô∏è Quick Sync**: 3-5 minutes download + extraction\n- **üîí Validator Safe**: Automatic state backup/restore\n- **üîÑ Always Fresh**: Updated every 6 hours\n- **üåê Reliable**: Professional infrastructure with 99.9% uptime"
        },
        {
          "id": "alternative-methods",
          "title": "Alternative Methods",
          "icon": "üîÑ",
          "type": "page",
          "content": "# üîÑ Alternative Snapshot Methods\n\n## ‚ö° Quick Commands\n\n```bash\n# Quick one-liner for advanced users\ncurl -s https://snaps.coinsspor.com/story/aeneid/coinsspor-info.json | jq -r '\"aria2c --split=8 --max-connection-per-server=8 https://snaps.coinsspor.com/story/aeneid/\" + .snapshots.consensus, \"aria2c --split=8 --max-connection-per-server=8 https://snaps.coinsspor.com/story/aeneid/\" + .snapshots.execution'\n```\n\n## üåê Manual Download\n\nIf you prefer manual download, visit: https://snaps.coinsspor.com/story/aeneid/\n\n**Available files:**\n- `coinsspor-aeneid-consensus-HEIGHT-DATE.tar.zst` - Story consensus data (ZSTD)\n- `coinsspor-aeneid-execution-HEIGHT-DATE.tar.zst` - Geth execution data (ZSTD)\n- `coinsspor-info.json` - Snapshot metadata and service info\n- `coinsspor-height.txt` - Current snapshot block height\n\n## üì± Quick Status Commands\n\n```bash\n# Check service status\ncurl -s https://snaps.coinsspor.com/story/aeneid/coinsspor-info.json | jq '.service, .block_height, .timestamp'\n\n# Get current snapshot height\ncurl -s https://snaps.coinsspor.com/story/aeneid/coinsspor-height.txt\n\n# Compare with your node (auto-detects port)\nSTORY_PORT=$(grep -E \"^laddr = \\\"tcp://.*:[0-9]+\\\"\" \"$HOME/.story/story/config/config.toml\" 2>/dev/null | grep -oE \"[0-9]+\" || echo \"26657\")\necho \"Snapshot: $(curl -s https://snaps.coinsspor.com/story/aeneid/coinsspor-height.txt)\"\necho \"Your Node: $(curl -s \"localhost:$STORY_PORT/status\" | jq -r '.result.sync_info.latest_block_height')\"\n```\n\n## üõ°Ô∏è Validator Safety Features\n\n- **Double Signing Protection**: Automatic `priv_validator_state.json` backup/restore\n- **Service Management**: Safe stop/start sequence\n- **Data Integrity**: ZSTD verification and error handling\n- **Rollback Support**: Automatic recovery on failure\n\n## üÜò Troubleshooting\n\n**Missing dependencies:**\n```bash\n# Install missing packages\nsudo apt install -y aria2 zstd jq curl\n```\n\n**Download fails:**\n```bash\n# Check network connectivity\ncurl -I https://snaps.coinsspor.com/story/aeneid/coinsspor-info.json\n\n# Manual retry with different settings\naria2c --max-connection-per-server=4 --split=4 [URL]\n```\n\n**Extraction fails:**\n```bash\n# Test ZSTD file integrity\nzstd -t snapshot_file.tar.zst\n\n# Manual extraction\nzstd -d snapshot_file.tar.zst\ntar -tf snapshot_file.tar | head -10\n```\n\n## üîß Custom Snapshot Script\n\n```bash\n# Create custom snapshot download script\ncat > $HOME/download_snapshot.sh << 'EOF'\n#!/bin/bash\n\necho \"üîΩ Custom Snapshot Download\"\necho \"==========================\"\n\n# Configuration\nSNAPSHOT_URL=\"https://snaps.coinsspor.com/story/aeneid\"\nSTORY_DATA=\"$HOME/.story\"\n\n# Get latest snapshot info\necho \"üìä Fetching snapshot information...\"\nINFO=$(curl -s \"$SNAPSHOT_URL/coinsspor-info.json\")\nHEIGHT=$(echo \"$INFO\" | jq -r '.block_height')\nCONSENSUS_FILE=$(echo \"$INFO\" | jq -r '.snapshots.consensus')\nEXECUTION_FILE=$(echo \"$INFO\" | jq -r '.snapshots.execution')\n\necho \"Latest snapshot height: $HEIGHT\"\necho \"Consensus file: $CONSENSUS_FILE\"\necho \"Execution file: $EXECUTION_FILE\"\n\n# Download function\ndownload_with_aria2c() {\n    local file=$1\n    echo \"üì• Downloading $file...\"\n    aria2c \\\n        --max-connection-per-server=8 \\\n        --split=8 \\\n        --min-split-size=10M \\\n        --continue=true \\\n        --max-tries=3 \\\n        \"$SNAPSHOT_URL/$file\"\n}\n\n# Main download process\nif [ \"$1\" = \"consensus\" ]; then\n    download_with_aria2c \"$CONSENSUS_FILE\"\nelif [ \"$1\" = \"execution\" ]; then\n    download_with_aria2c \"$EXECUTION_FILE\"\nelif [ \"$1\" = \"both\" ] || [ -z \"$1\" ]; then\n    download_with_aria2c \"$CONSENSUS_FILE\"\n    download_with_aria2c \"$EXECUTION_FILE\"\nelse\n    echo \"Usage: $0 [consensus|execution|both]\"\n    exit 1\nfi\n\necho \"‚úÖ Download completed!\"\nEOF\n\nchmod +x $HOME/download_snapshot.sh\n\n# Usage examples:\n# ./download_snapshot.sh consensus    # Download only consensus\n# ./download_snapshot.sh execution    # Download only execution  \n# ./download_snapshot.sh both         # Download both (default)\n```\n\n*üåü Powered by Coinsspor - Advanced ZSTD compression technology*"
        }
      ]
    },
    {
      "id": "monitoring",
      "title": "Monitoring & Sync",
      "icon": "üìä",
      "type": "section",
      "children": [
        {
          "id": "sync-monitoring",
          "title": "Sync Monitoring",
          "icon": "üìà",
          "type": "page",
          "content": "# üìà Sync Monitoring\n\n## Start Services\n\n```bash\n# Reload systemd and start services\nsudo systemctl daemon-reload\n\n# Enable services\nsudo systemctl enable story-geth story\n\n# Start story-geth first\nsudo systemctl start story-geth\n\n# Wait a few seconds then start story\nsleep 5\nsudo systemctl start story\n\n# Check status\nsudo systemctl status story-geth\nsudo systemctl status story\n```\n\n## Check Sync Status\n\n```bash\n# Check if node is catching up\ncurl localhost:${STORY_PORT}657/status | jq '.result.sync_info.catching_up'\n\n# Get current block height\ncurl localhost:${STORY_PORT}657/status | jq '.result.sync_info.latest_block_height'\n\n# Check geth sync status\nstory-geth --exec \"eth.syncing\" attach ~/.story/geth/aeneid/geth.ipc\n```\n\n## üìà Live Sync Monitor Script\n\n```bash\n# Create comprehensive monitoring script\ncat > $HOME/monitor.sh << 'EOF'\n#!/bin/bash\n\n# Get port from environment variable\nsource $HOME/.bash_profile\nrpc_port=\"${STORY_PORT}657\"\nlocal_rpc=\"localhost:$rpc_port\"\nnetwork_rpc=\"https://aeneid.storyrpc.io\"\n\necho \"üöÄ Story Protocol Sync Monitor\"\necho \"==============================\"\necho \"Local RPC: $local_rpc\"\necho \"Network RPC: $network_rpc\"\necho \"Press Ctrl+C to stop monitoring\"\necho \"==============================\"\n\nwhile true; do\n local_height=$(curl -s \"$local_rpc/status\" | jq -r '.result.sync_info.latest_block_height')\n network_height=$(curl -s \"$network_rpc/status\" | jq -r '.result.sync_info.latest_block_height')\n\n if ! [[ \"$local_height\" =~ ^[0-9]+$ ]] || ! [[ \"$network_height\" =~ ^[0-9]+$ ]]; then\n   echo -e \"\\033[1;31m‚ùå Error: Failed to fetch block heights. Retrying...\\033[0m\"\n   sleep 5\n   continue\n fi\n\n blocks_left=$((network_height - local_height))\n if [ \"$blocks_left\" -lt 0 ]; then\n   blocks_left=0\n fi\n\n # Calculate sync percentage\n sync_percentage=$(echo \"scale=2; ($local_height / $network_height) * 100\" | bc -l 2>/dev/null || echo \"0\")\n\n echo -e \"\\033[1;33müìä Node Height:\\033[1;34m $local_height\\033[0m \\033[1;33m| üåê Network Height:\\033[1;36m $network_height\\033[0m \\033[1;33m| ‚è≥ Blocks Left:\\033[1;31m $blocks_left\\033[0m \\033[1;32m| üîÑ Sync: ${sync_percentage}%\\033[0m\"\n sleep 5\ndone\nEOF\n\n# Set execute permissions\nchmod +x $HOME/monitor.sh\n\n# Run the monitor\necho \"üöÄ Starting sync monitor...\"\ncd $HOME\n./monitor.sh\n```\n\n## üìä Advanced Monitoring Dashboard\n\n```bash\n# Create advanced monitoring dashboard\ncat > $HOME/dashboard.sh << 'EOF'\n#!/bin/bash\n\nsource $HOME/.bash_profile\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nPURPLE='\\033[0;35m'\nCYAN='\\033[0;36m'\nNC='\\033[0m' # No Color\n\nclear\n\nwhile true; do\n    # Get system info\n    LOAD=$(uptime | awk -F'load average:' '{print $2}')\n    MEMORY=$(free -h | awk '/^Mem:/ {print $3\"/\"$2}')\n    DISK=$(df -h $HOME/.story | awk 'NR==2 {print $3\"/\"$2 \" (\" $5 \" used)\"}')\n    \n    # Get network info\n    LOCAL_HEIGHT=$(curl -s localhost:${STORY_PORT}657/status 2>/dev/null | jq -r '.result.sync_info.latest_block_height' 2>/dev/null || echo \"N/A\")\n    NETWORK_HEIGHT=$(curl -s https://aeneid.storyrpc.io/status 2>/dev/null | jq -r '.result.sync_info.latest_block_height' 2>/dev/null || echo \"N/A\")\n    CATCHING_UP=$(curl -s localhost:${STORY_PORT}657/status 2>/dev/null | jq -r '.result.sync_info.catching_up' 2>/dev/null || echo \"N/A\")\n    PEERS=$(curl -s localhost:${STORY_PORT}657/net_info 2>/dev/null | jq -r '.result.n_peers' 2>/dev/null || echo \"N/A\")\n    \n    # Get service status\n    STORY_STATUS=$(systemctl is-active story 2>/dev/null || echo \"inactive\")\n    GETH_STATUS=$(systemctl is-active story-geth 2>/dev/null || echo \"inactive\")\n    \n    # Calculate sync percentage and blocks behind\n    if [[ \"$LOCAL_HEIGHT\" =~ ^[0-9]+$ ]] && [[ \"$NETWORK_HEIGHT\" =~ ^[0-9]+$ ]]; then\n        BLOCKS_BEHIND=$((NETWORK_HEIGHT - LOCAL_HEIGHT))\n        SYNC_PERCENT=$(echo \"scale=2; ($LOCAL_HEIGHT / $NETWORK_HEIGHT) * 100\" | bc -l 2>/dev/null || echo \"0\")\n    else\n        BLOCKS_BEHIND=\"N/A\"\n        SYNC_PERCENT=\"N/A\"\n    fi\n    \n    # Clear screen and display dashboard\n    clear\n    echo -e \"${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}\"\n    echo -e \"${PURPLE}‚ïë                          üìä Story Protocol Dashboard                          ‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC} ${CYAN}üñ•Ô∏è  System Resources${NC}                                                      ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üíæ Memory: ${YELLOW}$MEMORY${NC}                                                    ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üíø Disk: ${YELLOW}$DISK${NC}                                            ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   ‚ö° Load: ${YELLOW}$LOAD${NC}                                                      ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}                                                                              ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC} ${CYAN}üåê Network Status${NC}                                                         ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üìà Local Height: ${GREEN}$LOCAL_HEIGHT${NC}                                         ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üåç Network Height: ${GREEN}$NETWORK_HEIGHT${NC}                                     ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   ‚è≥ Blocks Behind: ${RED}$BLOCKS_BEHIND${NC}                                         ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üîÑ Sync Progress: ${BLUE}$SYNC_PERCENT%${NC}                                        ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üîó Connected Peers: ${CYAN}$PEERS${NC}                                              ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üì° Catching Up: ${YELLOW}$CATCHING_UP${NC}                                           ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}                                                                              ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC} ${CYAN}üîß Service Status${NC}                                                         ${PURPLE}‚ïë${NC}\"\n    \n    if [ \"$STORY_STATUS\" = \"active\" ]; then\n        echo -e \"${PURPLE}‚ïë${NC}   üì¶ Story: ${GREEN}‚óè${NC} $STORY_STATUS                                                ${PURPLE}‚ïë${NC}\"\n    else\n        echo -e \"${PURPLE}‚ïë${NC}   üì¶ Story: ${RED}‚óè${NC} $STORY_STATUS                                              ${PURPLE}‚ïë${NC}\"\n    fi\n    \n    if [ \"$GETH_STATUS\" = \"active\" ]; then\n        echo -e \"${PURPLE}‚ïë${NC}   ‚ö° Story-Geth: ${GREEN}‚óè${NC} $GETH_STATUS                                          ${PURPLE}‚ïë${NC}\"\n    else\n        echo -e \"${PURPLE}‚ïë${NC}   ‚ö° Story-Geth: ${RED}‚óè${NC} $GETH_STATUS                                        ${PURPLE}‚ïë${NC}\"\n    fi\n    \n    echo -e \"${PURPLE}‚ïë${NC}                                                                              ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC} ${CYAN}üìä Statistics${NC}                                                             ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üîå RPC Port: ${YELLOW}${STORY_PORT}657${NC}                                              ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üì° API Port: ${YELLOW}${STORY_PORT}317${NC}                                              ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   üåê P2P Port: ${YELLOW}${STORY_PORT}656${NC}                                              ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïë${NC}   ‚è∞ Last Update: ${CYAN}$(date)${NC}                                ${PURPLE}‚ïë${NC}\"\n    echo -e \"${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}\"\n    echo -e \"${YELLOW}Press Ctrl+C to exit${NC}\"\n    \n    sleep 5\ndone\nEOF\n\nchmod +x $HOME/dashboard.sh\necho \"‚úÖ Advanced dashboard created: $HOME/dashboard.sh\"\n```\n\n## üîç Service Health Check\n\n```bash\n# Create health check script\ncat > $HOME/health_check.sh << 'EOF'\n#!/bin/bash\n\necho \"üè• Story Node Health Check\"\necho \"==========================\"\n\n# Check services\necho \"üìã Service Status:\"\nSTORY_STATUS=$(systemctl is-active story)\nGETH_STATUS=$(systemctl is-active story-geth)\n\nif [ \"$STORY_STATUS\" = \"active\" ]; then\n    echo \"‚úÖ Story service: Running\"\nelse\n    echo \"‚ùå Story service: $STORY_STATUS\"\nfi\n\nif [ \"$GETH_STATUS\" = \"active\" ]; then\n    echo \"‚úÖ Story-Geth service: Running\"\nelse\n    echo \"‚ùå Story-Geth service: $GETH_STATUS\"\nfi\n\n# Check API endpoints\necho \"\\nüåê API Health:\"\ncurl -s --max-time 5 localhost:${STORY_PORT}657/health >/dev/null && echo \"‚úÖ Story RPC: Healthy\" || echo \"‚ùå Story RPC: Unhealthy\"\ncurl -s --max-time 5 localhost:${STORY_PORT}545 -X POST -H \"Content-Type: application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"net_version\",\"params\":[],\"id\":1}' >/dev/null && echo \"‚úÖ Geth RPC: Healthy\" || echo \"‚ùå Geth RPC: Unhealthy\"\n\n# Check sync status\necho \"\\nüìä Sync Status:\"\nCATCHING_UP=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.catching_up' 2>/dev/null)\nif [ \"$CATCHING_UP\" = \"false\" ]; then\n    echo \"‚úÖ Node: Fully synced\"\nelif [ \"$CATCHING_UP\" = \"true\" ]; then\n    echo \"üîÑ Node: Syncing in progress\"\nelse\n    echo \"‚ùå Node: Status unknown\"\nfi\n\n# Check peer connections\nPEER_COUNT=$(curl -s localhost:${STORY_PORT}657/net_info | jq -r '.result.n_peers' 2>/dev/null)\nif [[ \"$PEER_COUNT\" =~ ^[0-9]+$ ]] && [ \"$PEER_COUNT\" -gt 0 ]; then\n    echo \"‚úÖ Peers: Connected to $PEER_COUNT peers\"\nelse\n    echo \"‚ùå Peers: No connections or error\"\nfi\n\n# Check disk space\necho \"\\nüíæ Disk Usage:\"\nSTORY_SIZE=$(du -sh $HOME/.story 2>/dev/null | cut -f1)\nDISK_USAGE=$(df -h $HOME/.story | awk 'NR==2 {print $5}' | tr -d '%')\n\necho \"üìÅ Story data size: $STORY_SIZE\"\nif [ \"$DISK_USAGE\" -lt 80 ]; then\n    echo \"‚úÖ Disk usage: ${DISK_USAGE}% (healthy)\"\nelif [ \"$DISK_USAGE\" -lt 90 ]; then\n    echo \"‚ö†Ô∏è  Disk usage: ${DISK_USAGE}% (warning)\"\nelse\n    echo \"‚ùå Disk usage: ${DISK_USAGE}% (critical)\"\nfi\n\necho \"==========================\"\nEOF\n\nchmod +x $HOME/health_check.sh\n```\n\n## üì± Quick Status Commands\n\n```bash\n# Quick sync check\nalias story-status='curl -s localhost:${STORY_PORT}657/status | jq \"{height: .result.sync_info.latest_block_height, catching_up: .result.sync_info.catching_up, peers: .result.sync_info}\"'\n\n# Quick peer count\nalias story-peers='curl -s localhost:${STORY_PORT}657/net_info | jq \".result.n_peers\"'\n\n# Quick service status\nalias story-services='systemctl status story story-geth --no-pager -l'\n\n# Add to bash profile\necho \"alias story-status='curl -s localhost:${STORY_PORT}657/status | jq \\\"{height: .result.sync_info.latest_block_height, catching_up: .result.sync_info.catching_up}\\\"'\" >> ~/.bash_profile\necho \"alias story-peers='curl -s localhost:${STORY_PORT}657/net_info | jq \\\".result.n_peers\\\"'\" >> ~/.bash_profile\necho \"alias story-services='systemctl status story story-geth --no-pager -l'\" >> ~/.bash_profile\n\nsource ~/.bash_profile\n```"
        }
      ]
    },
    {
      "id": "validator-setup",
      "title": "Validator Setup",
      "icon": "üèÜ",
      "type": "section",
      "children": [
        {
          "id": "validator-creation",
          "title": "Validator Creation",
          "icon": "üëë",
          "type": "page",
          "content": "# üëë Validator Creation\n\n## Step 1: Export Validator Keys\n\n```bash\n# Export validator public key\nstory validator export\n\n# Export EVM private key to file\nstory validator export --export-evm-key\n```\n\n## Step 2: Setup .env File\n\n```bash\n# Create .env file in the Story config directory (more secure and organized)\necho \"PRIVATE_KEY=$(cat $HOME/.story/story/config/private_key.txt | grep \"PRIVATE_KEY\" | awk -F'=' '{print $2}')\" > $HOME/.story/story/config/.env\n\n# Verify .env file (DO NOT share this output)\necho \"‚úÖ .env file created in $HOME/.story/story/config/\"\necho \"‚ö†Ô∏è  Keep your .env file secure and never share it!\"\n\n# Check if .env file is correctly formatted\nif [ -f \"$HOME/.story/story/config/.env\" ]; then\n    echo \"‚úÖ .env file exists in config directory\"\nelse\n    echo \"‚ùå .env file creation failed\"\n    exit 1\nfi\n\n# Set proper permissions for security\nchmod 600 $HOME/.story/story/config/.env\necho \"‚úÖ .env file permissions set to 600 (owner read/write only)\"\n```\n\n## Step 3: Wait for Full Sync\n\n**‚ö†Ô∏è IMPORTANT: Your node must be fully synced before creating a validator!**\n\n```bash\n# Check sync status\necho \"üîç Checking sync status...\"\nSYNC_STATUS=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.catching_up')\nCURRENT_HEIGHT=$(curl -s localhost:${STORY_PORT}657/status | jq -r '.result.sync_info.latest_block_height')\nNETWORK_HEIGHT=$(curl -s https://aeneid.storyrpc.io/status | jq -r '.result.sync_info.latest_block_height')\n\necho \"üìä Sync Information:\"\necho \"Current Height: $CURRENT_HEIGHT\"\necho \"Network Height: $NETWORK_HEIGHT\"\necho \"Catching Up: $SYNC_STATUS\"\n\nif [ \"$SYNC_STATUS\" = \"false\" ]; then\n    echo \"‚úÖ Node is fully synced! Ready to create validator.\"\nelse\n    echo \"‚è≥ Node is still syncing. Please wait for full sync before creating validator.\"\n    echo \"üí° Use: ./monitor.sh to track sync progress\"\n    exit 1\nfi\n```\n\n## Step 4: Create Validator\n\n```bash\n# Navigate to the directory containing .env file\ncd $HOME/.story/story/config/\n\n# For LOCKED tokens (recommended for competition):\nstory validator create \\\n  --stake 1024000000000000000000 \\\n  --moniker \"$STORY_MONIKER\" \\\n  --chain-id 1315 \\\n  --unlocked=false \\\n  --rpc \"https://aeneid.storyrpc.io\"\n\n# For UNLOCKED tokens:\nstory validator create \\\n  --stake 1024000000000000000000 \\\n  --moniker \"$STORY_MONIKER\" \\\n  --chain-id 1315 \\\n  --unlocked=true \\\n  --rpc \"https://aeneid.storyrpc.io\"\n```\n\n## üìä Validator Parameters Explained\n\n| Parameter | Value | Description |\n|-----------|-------|-------------|\n| `--stake` | 1024000000000000000000 | Minimum stake (1024 IP in wei) |\n| `--moniker` | Your node name | Validator display name |\n| `--chain-id` | 1315 | Aeneid testnet chain ID |\n| `--unlocked` | true/false | Token lock status |\n| `--rpc` | Official RPC | Network endpoint |\n\n### üîí Locked vs Unlocked Tokens\n\n**Locked Tokens (Recommended):**\n- ‚úÖ Better for competition scoring\n- ‚úÖ Shows long-term commitment\n- ‚úÖ Higher security\n- ‚ùå Cannot be withdrawn immediately\n\n**Unlocked Tokens:**\n- ‚úÖ Can be withdrawn anytime\n- ‚úÖ More flexibility\n- ‚ùå Lower competition scoring\n- ‚ùå May appear less committed\n\n## Step 5: Verify Validator Creation\n\n```bash\n# Get your validator public key\nVALIDATOR_PUBKEY=$(story validator export | grep \"Compressed Public Key (hex)\" | awk '{print $NF}')\necho \"üîë Validator Public Key: $VALIDATOR_PUBKEY\"\n\n# Check if validator appears in validator set\necho \"üîç Checking validator in set...\"\ncurl -s \"https://aeneid.storyrpc.io/validators\" | jq --arg pubkey \"$VALIDATOR_PUBKEY\" '.result.validators[] | select(.pub_key.value == $pubkey)'\n\n# Check validator status\necho \"üìä Validator Status:\"\nstory query staking validator $VALIDATOR_PUBKEY --rpc https://aeneid.storyrpc.io\n```\n\n## üéØ Post-Creation Checklist\n\n- [ ] Validator created successfully\n- [ ] Public key exported and saved\n- [ ] .env file secured (chmod 600)\n- [ ] Validator appears in validator set\n- [ ] Node is fully synced\n- [ ] Monitoring setup active\n\n## üîê Security Best Practices\n\n```bash\n# Backup critical files\necho \"üíæ Creating validator backup...\"\nmkdir -p $HOME/validator_backup\n\n# Backup validator key (MOST IMPORTANT)\ncp $HOME/.story/story/config/priv_validator_key.json $HOME/validator_backup/\n\n# Backup node key\ncp $HOME/.story/story/config/node_key.json $HOME/validator_backup/\n\n# Backup .env file\ncp $HOME/.story/story/config/.env $HOME/validator_backup/\n\n# Set secure permissions\nchmod 600 $HOME/validator_backup/*\n\necho \"‚úÖ Validator backup created in $HOME/validator_backup/\"\necho \"‚ö†Ô∏è  Store these files safely - they cannot be recovered if lost!\"\n```\n\n**Important Notes:**\n- ‚úÖ Story v1.2.0+ requires `.env` file for all operations\n- ‚úÖ The `.env` file must be in the same directory where you run commands\n- ‚úÖ Never commit or share your `.env` file\n- ‚úÖ Minimum stake is 1024 IP (1024000000000000000000 wei)\n- ‚úÖ Always backup your validator keys before any operations\n\n:::warning\n**Critical Security Warning:**\n- Never share your `priv_validator_key.json` file\n- Never share your `.env` file or private key\n- Always backup these files to a secure location\n- Double signing can result in slashing penalties\n:::"
        },
        {
          "id": "staking-operations",
          "title": "Staking Operations",
          "icon": "ü•©",
          "type": "page",
          "content": "# ü•© Staking Operations\n\n## Step 1: Get Your Validator Public Key\n\n```bash\n# Get your validator public key\nVALIDATOR_PUBKEY=$(story validator export | grep \"Compressed Public Key (hex)\" | awk '{print $NF}')\necho \"üîë Your Validator Public Key: $VALIDATOR_PUBKEY\"\n\n# Save for future use\necho \"export VALIDATOR_PUBKEY=$VALIDATOR_PUBKEY\" >> $HOME/.bash_profile\nsource $HOME/.bash_profile\n```\n\n## Step 2: Delegate Additional Stake\n\n```bash\n# Navigate to the directory containing .env file\ncd $HOME/.story/story/config/\n\n# Delegate additional stake to your validator\nstory validator stake \\\n  --chain-id 1315 \\\n  --validator-pubkey $VALIDATOR_PUBKEY \\\n  --stake 1000000000000000000000 \\\n  --rpc \"https://aeneid.storyrpc.io\"\n```\n\n## üìä Staking Parameters\n\n| Parameter | Description | Example Value |\n|-----------|-------------|---------------|\n| `--stake` | Amount to stake (wei) | 1000000000000000000000 (1000 IP) |\n| `--validator-pubkey` | Your validator's public key | 0x... |\n| `--chain-id` | Network chain ID | 1315 |\n| `--rpc` | RPC endpoint | https://aeneid.storyrpc.io |\n\n## üí∞ Stake Amount Calculations\n\n```bash\n# Helper function to calculate stake amounts\ncalculate_stake() {\n    local ip_amount=$1\n    local wei_amount=$(echo \"$ip_amount * 1000000000000000000000\" | bc -l)\n    echo \"${wei_amount%.*}\"  # Remove decimal places\n}\n\n# Examples:\necho \"1 IP = $(calculate_stake 1) wei\"\necho \"100 IP = $(calculate_stake 100) wei\"\necho \"1000 IP = $(calculate_stake 1000) wei\"\necho \"1024 IP = $(calculate_stake 1024) wei\"  # Minimum for validator\n\n# Quick conversion tool\ncat > $HOME/stake_calculator.sh << 'EOF'\n#!/bin/bash\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 <IP_AMOUNT>\"\n    echo \"Example: $0 1000\"\n    exit 1\nfi\n\nIP_AMOUNT=$1\nWEI_AMOUNT=$(echo \"$IP_AMOUNT * 1000000000000000000000\" | bc -l)\nWEI_CLEAN=${WEI_AMOUNT%.*}\n\necho \"üí∞ Stake Conversion:\"\necho \"IP Amount: $IP_AMOUNT\"\necho \"Wei Amount: $WEI_CLEAN\"\necho \"\"\necho \"üìã Copy this for staking command:\"\necho \"--stake $WEI_CLEAN\"\nEOF\n\nchmod +x $HOME/stake_calculator.sh\n\n# Usage: ./stake_calculator.sh 1000\n```\n\n## üîç Check Staking Status\n\n```bash\n# Check your delegations\necho \"üìä Checking delegation status...\"\n\n# Get your delegator address (derived from validator key)\nDELEGATOR_ADDRESS=$(story keys show validator --keyring-backend test --output json | jq -r '.address')\n\nif [ \"$DELEGATOR_ADDRESS\" != \"null\" ] && [ -n \"$DELEGATOR_ADDRESS\" ]; then\n    echo \"üè¶ Delegator Address: $DELEGATOR_ADDRESS\"\n    \n    # Check delegations\n    story query staking delegations $DELEGATOR_ADDRESS --rpc https://aeneid.storyrpc.io\nelse\n    echo \"‚ö†Ô∏è  Could not determine delegator address\"\n    echo \"üí° Try: story keys list --keyring-backend test\"\nfi\n\n# Check validator details\necho \"\\nüìà Validator Details:\"\nstory query staking validator $VALIDATOR_PUBKEY --rpc https://aeneid.storyrpc.io\n```\n\n## üìà Monitor Validator Performance\n\n```bash\n# Create validator monitoring script\ncat > $HOME/validator_monitor.sh << 'EOF'\n#!/bin/bash\n\nsource $HOME/.bash_profile\n\necho \"üëë Validator Performance Monitor\"\necho \"================================\"\n\n# Get validator info\nif [ -z \"$VALIDATOR_PUBKEY\" ]; then\n    echo \"‚ùå VALIDATOR_PUBKEY not set. Run validator export first.\"\n    exit 1\nfi\n\necho \"üîë Validator: $VALIDATOR_PUBKEY\"\necho \"\"\n\n# Check if validator is in active set\necho \"üìä Validator Status:\"\nVALIDATOR_INFO=$(curl -s \"https://aeneid.storyrpc.io/validators\" | jq --arg pubkey \"$VALIDATOR_PUBKEY\" '.result.validators[] | select(.pub_key.value == $pubkey)')\n\nif [ -n \"$VALIDATOR_INFO\" ]; then\n    echo \"‚úÖ Validator is in active set\"\n    \n    VOTING_POWER=$(echo \"$VALIDATOR_INFO\" | jq -r '.voting_power')\n    echo \"‚ö° Voting Power: $VOTING_POWER\"\nelse\n    echo \"‚ùå Validator not in active set\"\nfi\n\n# Check recent block signing\necho \"\\nüìã Block Signing Status:\"\nLATEST_HEIGHT=$(curl -s https://aeneid.storyrpc.io/status | jq -r '.result.sync_info.latest_block_height')\nSIGNED_BLOCKS=0\nTOTAL_CHECKED=10\n\necho \"üîç Checking last $TOTAL_CHECKED blocks...\"\nfor i in $(seq 1 $TOTAL_CHECKED); do\n    HEIGHT=$((LATEST_HEIGHT - i))\n    BLOCK_INFO=$(curl -s \"https://aeneid.storyrpc.io/block?height=$HEIGHT\")\n    \n    # Check if our validator signed this block\n    if echo \"$BLOCK_INFO\" | jq -r '.result.block.last_commit.signatures[].validator_address' | grep -q \"$(echo \"$VALIDATOR_INFO\" | jq -r '.address')\"; then\n        SIGNED_BLOCKS=$((SIGNED_BLOCKS + 1))\n    fi\ndone\n\nSIGNING_RATE=$(echo \"scale=2; $SIGNED_BLOCKS * 100 / $TOTAL_CHECKED\" | bc -l)\necho \"üìà Signing Rate: $SIGNING_RATE% ($SIGNED_BLOCKS/$TOTAL_CHECKED blocks)\"\n\nif (( $(echo \"$SIGNING_RATE >= 90\" | bc -l) )); then\n    echo \"‚úÖ Excellent performance!\"\nelif (( $(echo \"$SIGNING_RATE >= 70\" | bc -l) )); then\n    echo \"‚ö†Ô∏è  Good, but room for improvement\"\nelse\n    echo \"‚ùå Poor performance - check node health\"\nfi\n\necho \"================================\"\nEOF\n\nchmod +x $HOME/validator_monitor.sh\n```\n\n## üîÑ Advanced Staking Operations\n\n### Unstake Tokens\n\n```bash\n# Navigate to config directory\ncd $HOME/.story/story/config/\n\n# Unstake tokens (requires delegation ID)\nstory validator unstake \\\n  --validator-pubkey $VALIDATOR_PUBKEY \\\n  --unstake 1000000000000000000000 \\\n  --delegation-id 0 \\\n  --rpc \"https://aeneid.storyrpc.io\"\n```\n\n### Redelegate to Another Validator\n\n```bash\n# Redelegate stake to another validator\nSOURCE_VALIDATOR_PUBKEY=\"your_current_validator_pubkey\"\nDEST_VALIDATOR_PUBKEY=\"target_validator_pubkey\"\n\ncd $HOME/.story/story/config/\n\nstory validator redelegate \\\n  --validator-src-pubkey $SOURCE_VALIDATOR_PUBKEY \\\n  --validator-dst-pubkey $DEST_VALIDATOR_PUBKEY \\\n  --redelegate 1000000000000000000000 \\\n  --rpc \"https://aeneid.storyrpc.io\"\n```\n\n### Query Staking Information\n\n```bash\n# Check all validators\nstory query staking validators --rpc https://aeneid.storyrpc.io\n\n# Check staking pool\nstory query staking pool --rpc https://aeneid.storyrpc.io\n\n# Check staking parameters\nstory query staking params --rpc https://aeneid.storyrpc.io\n```\n\n## üéØ Staking Best Practices\n\n1. **Start with Minimum**: Begin with 1024 IP minimum stake\n2. **Gradual Increase**: Add stake gradually as you prove reliability\n3. **Monitor Performance**: Regular performance monitoring\n4. **Backup Everything**: Always backup keys before staking operations\n5. **Test First**: Test with small amounts first\n6. **Stay Updated**: Follow network upgrades and announcements\n\n## üìä Staking Economics\n\n```bash\n# Create staking economics calculator\ncat > $HOME/staking_economics.sh << 'EOF'\n#!/bin/bash\n\necho \"üí∞ Staking Economics Calculator\"\necho \"==============================\"\n\n# Current network parameters (approximate)\nANNUAL_INFLATION=7  # 7% annual inflation rate\nCOMMISSION_RATE=5   # 5% commission rate\nTOTAL_STAKED_IP=50000000  # Total staked IP (estimate)\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 <your_stake_in_IP>\"\n    echo \"Example: $0 10000\"\n    exit 1\nfi\n\nYOUR_STAKE=$1\n\n# Calculate approximate annual rewards\nNETWORK_REWARDS=$(echo \"scale=2; $TOTAL_STAKED_IP * $ANNUAL_INFLATION / 100\" | bc -l)\nYOUR_SHARE=$(echo \"scale=6; $YOUR_STAKE / $TOTAL_STAKED_IP\" | bc -l)\nGROSS_REWARDS=$(echo \"scale=2; $NETWORK_REWARDS * $YOUR_SHARE\" | bc -l)\nCOMMISSION=$(echo \"scale=2; $GROSS_REWARDS * $COMMISSION_RATE / 100\" | bc -l)\nNET_REWARDS=$(echo \"scale=2; $GROSS_REWARDS - $COMMISSION\" | bc -l)\nAPY=$(echo \"scale=2; $NET_REWARDS * 100 / $YOUR_STAKE\" | bc -l)\n\necho \"üìä Staking Projection for $YOUR_STAKE IP:\"\necho \"----------------------------------------\"\necho \"Network Annual Inflation: $ANNUAL_INFLATION%\"\necho \"Your Stake Share: $(echo \"scale=4; $YOUR_SHARE * 100\" | bc -l)%\"\necho \"Gross Annual Rewards: $GROSS_REWARDS IP\"\necho \"Commission (${COMMISSION_RATE}%): $COMMISSION IP\"\necho \"Net Annual Rewards: $NET_REWARDS IP\"\necho \"Estimated APY: $APY%\"\necho \"----------------------------------------\"\necho \"‚ö†Ô∏è  This is an estimate based on current parameters\"\nEOF\n\nchmod +x $HOME/staking_economics.sh\n\n# Usage: ./staking_economics.sh 10000\n```\n\n:::tip\n**Staking Tips:**\n- Always keep some IP unstaked for transaction fees\n- Monitor your validator's performance regularly\n- Participate in governance to earn additional rewards\n- Keep your node updated and well-maintained\n- Consider the lock period when staking\n:::"
        }
      ]
    },
    {
      "id": "useful-commands",
      "title": "Useful Commands",
      "icon": "üîß",
      "type": "section",
      "children": [
        {
          "id": "service-management",
          "title": "Service Management",
          "icon": "‚öôÔ∏è",
          "type": "page",
          "content": "# ‚öôÔ∏è Service Management\n\n## üìã Service Status Commands\n\n```bash\n# Check service status\nsudo systemctl status story\nsudo systemctl status story-geth\n\n# Check if services are running\nsudo systemctl is-active story\nsudo systemctl is-active story-geth\n\n# Check if services are enabled (start on boot)\nsudo systemctl is-enabled story\nsudo systemctl is-enabled story-geth\n```\n\n## üîÑ Service Control Commands\n\n```bash\n# Start services\nsudo systemctl start story-geth  # Start execution layer first\nsleep 5\nsudo systemctl start story       # Then consensus layer\n\n# Stop services\nsudo systemctl stop story         # Stop consensus layer first\nsudo systemctl stop story-geth    # Then execution layer\n\n# Restart services\nsudo systemctl restart story\nsudo systemctl restart story-geth\n\n# Restart both services in correct order\nsudo systemctl restart story story-geth\n```\n\n## üîß Service Configuration\n\n```bash\n# Reload systemd configuration\nsudo systemctl daemon-reload\n\n# Enable services (start on boot)\nsudo systemctl enable story\nsudo systemctl enable story-geth\n\n# Disable services\nsudo systemctl disable story\nsudo systemctl disable story-geth\n\n# Show service configuration\nsudo systemctl cat story\nsudo systemctl cat story-geth\n```\n\n## üìä Service Monitoring\n\n```bash\n# View real-time logs\nsudo journalctl -u story -f\nsudo journalctl -u story-geth -f\n\n# View both services together\nsudo journalctl -u story -u story-geth -f\n\n# View logs with colors\nsudo journalctl -u story -f -o cat\n\n# View recent logs\nsudo journalctl -u story -n 50 --no-pager\nsudo journalctl -u story-geth -n 50 --no-pager\n\n# View logs since specific time\nsudo journalctl -u story --since \"1 hour ago\"\nsudo journalctl -u story --since \"2025-01-13 10:00:00\"\n\n# View logs with specific priority\nsudo journalctl -u story -p err  # Only errors\nsudo journalctl -u story -p warning  # Warnings and above\n```\n\n## üîç Advanced Log Analysis\n\n```bash\n# Search for specific patterns in logs\nsudo journalctl -u story | grep -i \"error\\|fail\\|panic\"\nsudo journalctl -u story-geth | grep -i \"connection\\|peer\"\n\n# Count specific log entries\nsudo journalctl -u story --since \"1 hour ago\" | grep -c \"ERROR\"\n\n# Export logs to file\nsudo journalctl -u story --since \"today\" > story_logs_$(date +%Y%m%d).log\n\n# Clear old logs (keep last 3 days)\nsudo journalctl --vacuum-time=3d\n\n# Check log disk usage\nsudo journalctl --disk-usage\n```\n\n## üõ†Ô∏è Service Troubleshooting\n\n```bash\n# Create service diagnostic script\ncat > $HOME/service_diagnostics.sh << 'EOF'\n#!/bin/bash\n\necho \"üîß Service Diagnostics\"\necho \"=====================\"\n\n# Service status\necho \"üìä Service Status:\"\necho \"Story: $(systemctl is-active story) ($(systemctl is-enabled story))\"\necho \"Story-Geth: $(systemctl is-active story-geth) ($(systemctl is-enabled story-geth))\"\n\n# Process information\necho \"\\nüîç Process Information:\"\nps aux | grep -E \"(cosmovisor|story|geth)\" | grep -v grep\n\n# Port status\necho \"\\nüîå Port Status:\"\nfor port in \"${STORY_PORT}657\" \"${STORY_PORT}656\" \"${STORY_PORT}545\" \"${STORY_PORT}303\"; do\n    if netstat -tuln | grep -q \":$port \"; then\n        echo \"‚úÖ Port $port: Active\"\n    else\n        echo \"‚ùå Port $port: Not active\"\n    fi\ndone\n\n# Recent errors\necho \"\\n‚ö†Ô∏è  Recent Errors (last 10 minutes):\"\necho \"Story errors:\"\nsudo journalctl -u story --since \"10 minutes ago\" | grep -i \"error\\|fail\\|panic\" | tail -3\necho \"\\nGeth errors:\"\nsudo journalctl -u story-geth --since \"10 minutes ago\" | grep -i \"error\\|fail\\|panic\" | tail -3\n\n# File permissions\necho \"\\nüìÅ Critical File Permissions:\"\nls -la $HOME/go/bin/story $HOME/go/bin/story-geth $HOME/go/bin/cosmovisor 2>/dev/null\nls -la $HOME/.story/story/config/priv_validator_key.json 2>/dev/null\n\necho \"=====================\"\nEOF\n\nchmod +x $HOME/service_diagnostics.sh\n\n# Run diagnostics\n./service_diagnostics.sh\n```\n\n## üîÑ Service Reset and Recovery\n\n```bash\n# Force stop all related processes\nkillall -9 story cosmovisor story-geth 2>/dev/null\n\n# Clean restart sequence\necho \"üõë Stopping all services...\"\nsudo systemctl stop story story-geth\nsleep 5\n\necho \"üîÑ Starting services in correct order...\"\nsudo systemctl start story-geth\necho \"‚è≥ Waiting for Story-Geth to initialize...\"\nsleep 15\n\nsudo systemctl start story\necho \"‚è≥ Waiting for Story to start...\"\nsleep 10\n\necho \"‚úÖ Services restarted. Checking status...\"\nsudo systemctl status story story-geth --no-pager\n```\n\n## üìà Performance Monitoring\n\n```bash\n# Create performance monitoring script\ncat > $HOME/performance_monitor.sh << 'EOF'\n#!/bin/bash\n\necho \"üìà Service Performance Monitor\"\necho \"==============================\"\n\nwhile true; do\n    clear\n    echo \"üìä $(date)\"\n    echo \"==============================\"\n    \n    # CPU and Memory usage\n    echo \"üíª Resource Usage:\"\n    ps aux | grep -E \"(story|geth|cosmovisor{
  "documentation": [
    {
      "id": "getting-started",
      "title": "Getting Started",
      "icon": "üöÄ",
      "type": "section",
      "children": [
        {
          "id": "overview",
          "title": "Overview",
          "icon": "üåå",
          "type": "page",
          "content": "# üåå Story Protocol Aeneid Testnet Complete Node Setup Guide\n\n> **The Ultimate Guide to Setting Up Your Story Protocol Aeneid Testnet Node with Cosmovisor**\n\nWelcome to the most comprehensive guide for setting up a Story Protocol Aeneid Testnet node! This guide covers everything from installation to validator setup, monitoring, and maintenance.\n\n## ‚ú® What You'll Learn\n\n- Complete node setup from scratch\n- Cosmovisor configuration for automatic upgrades\n- Advanced monitoring and troubleshooting\n- Validator creation and management\n- Competition participation strategies\n\n## üéØ Prerequisites\n\n- Ubuntu 22.04 LTS server\n- Basic command line knowledge\n- At least 500GB NVMe SSD storage\n- 16GB+ RAM (32GB recommended)\n\n:::tip\nThis guide uses dynamic port configuration, so you can run multiple nodes on the same server without conflicts!\n:::"
        },
        {
          "id": "system-requirements",
          "title": "System Requirements",
          "icon": "üñ•Ô∏è",
          "type": "page",
          "content": "# üñ•Ô∏è System Requirements\n\n## Minimum Hardware Requirements\n\n| Component | Minimum | Recommended |\n|-----------|---------|-------------|\n| **CPU** | 4 cores | 8 cores |\n| **RAM** | 16 GB | 32 GB |\n| **Storage** | 500 GB NVMe SSD | 1 TB NVMe SSD |\n| **OS** | Ubuntu 22.04 LTS | Ubuntu 22.04 LTS |\n| **Network** | 100 Mbps | 1 Gbps |\n\n## üîå Port Configuration (Dynamic based on your prefix)\n\n| Service | Port Formula | Example (prefix=26) | Example (prefix=56) |\n|---------|--------------|---------------------|--------------------||\n| Story P2P | `${STORY_PORT}656` | 26656 | 56656 |\n| Story RPC | `${STORY_PORT}657` | 26657 | 56657 |\n| Story API | `${STORY_PORT}317` | 26317 | 56317 |\n| Story Prometheus | `${STORY_PORT}660` | 26660 | 56660 |\n| Story-Geth P2P | `${STORY_PORT}303` | 26303 | 56303 |\n| Story-Geth RPC | `${STORY_PORT}545` | 26545 | 56545 |\n| Story-Geth WS | `${STORY_PORT}546` | 26546 | 56546 |\n| Story-Geth Auth | `${STORY_PORT}551` | 26551 | 56551 |\n| Story-Geth Metrics | `${STORY_PORT}060` | 26060 | 56060 |\n\n:::warning\nMake sure your firewall allows traffic on these ports. The dynamic port system allows running multiple nodes on the same server.\n:::\n\n## üåê Network Requirements\n\n- **Bandwidth**: Minimum 100 Mbps up/down\n- **Latency**: Less than 100ms to major data centers\n- **Stability**: 99%+ uptime for validator operations\n\n## üîß Operating System Setup\n\n```bash\n# Update system packages\nsudo apt update && sudo apt upgrade -y\n\n# Install required dependencies\nsudo apt install -y curl git wget htop tmux build-essential jq make lz4 gcc unzip aria2\n```"
        }
      ]
    },
    {
      "id": "endpoints-resources",
      "title": "Endpoints & Resources",
      "icon": "üì°",
      "type": "section",
      "children": [
        {
          "id": "coinsspor-endpoints",
          "title": "Coinsspor Endpoints",
          "icon": "üåü",
          "type": "page",
          "content": "# üåü Coinsspor Endpoints\n\n## Production Endpoints\n\n| Service | Endpoint | Type |\n|---------|----------|------|\n| üîπ **Cosmos RPC** | [https://story-aeneid-testnet-rpc.coinsspor.com](https://story-aeneid-testnet-rpc.coinsspor.com) | REST API |\n| üîπ **Cosmos WebSocket** | [wss://story-aeneid-testnet-rpc.coinsspor.com/websocket](wss://story-aeneid-testnet-rpc.coinsspor.com/websocket) | WebSocket |\n| üîπ **Cosmos REST API** | [https://story-aeneid-testnet-api.coinsspor.com](https://story-aeneid-testnet-api.coinsspor.com) | REST API |\n| üü£ **EVM RPC** | [https://story-aeneid-testnet-evm.coinsspor.com](https://story-aeneid-testnet-evm.coinsspor.com) | JSON-RPC |\n| üü£ **EVM WebSocket** | [wss://story-aeneid-testnet-evm.coinsspor.com](wss://story-aeneid-testnet-evm.coinsspor.com) | WebSocket |\n\n## üöÄ Performance Features\n\n- **99.9% Uptime**: Professional infrastructure\n- **Global CDN**: Optimized worldwide access\n- **Rate Limiting**: Fair usage policies\n- **SSL Security**: All endpoints secured with HTTPS/WSS\n- **Load Balancing**: Automatic failover protection\n\n## üìä Usage Examples\n\n### Check Node Status\n```bash\n# Get node status via Coinsspor RPC\ncurl -s https://story-aeneid-testnet-rpc.coinsspor.com/status | jq '.result.sync_info'\n```\n\n### WebSocket Connection\n```javascript\n// Connect to Coinsspor WebSocket\nconst ws = new WebSocket('wss://story-aeneid-testnet-rpc.coinsspor.com/websocket');\nws.onmessage = (event) => {\n  console.log('Received:', JSON.parse(event.data));\n};\n```\n\n### EVM RPC Call\n```bash\n# Get latest block number\ncurl -X POST https://story-aeneid-testnet-evm.coinsspor.com \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}'\n```"
        },
        {
          "id": "official-resources",
          "title": "Official Resources",
          "icon": "üåê",
          "type": "page",
          "content": "# üåê Official Resources\n\n## Network Information\n\n| Resource | Link | Description |\n|----------|------|-------------|\n| **Chain ID** | `1315` | Aeneid Testnet Chain ID |\n| **Official RPC** | [https://aeneid.storyrpc.io](https://aeneid.storyrpc.io) | Official RPC Endpoint |\n| **Explorer** | [https://aeneid.storyscan.io](https://aeneid.storyscan.io) | Block Explorer |\n| **IP Explorer** | [https://aeneid.explorer.story.foundation](https://aeneid.explorer.story.foundation) | IP Explorer |\n| **Faucet** | [https://faucet.story.foundation](https://faucet.story.foundation) | Testnet Faucet |\n\n## üõ†Ô∏è Development Resources\n\n| Resource | Link | Description |\n|----------|------|-------------|\n| **Story Geth Releases** | [https://github.com/piplabs/story-geth/releases](https://github.com/piplabs/story-geth/releases) | Latest Releases |\n| **Story Releases** | [https://github.com/piplabs/story/releases](https://github.com/piplabs/story/releases) | Latest Releases |\n| **Documentation** | [https://docs.story.foundation](https://docs.story.foundation) | Official Docs |\n| **GitHub** | [https://github.com/piplabs](https://github.com/piplabs) | Source Code |\n\n## üîß Current Network Stats\n\n```bash\n# Check network status\ncurl -s https://aeneid.storyrpc.io/status | jq '.result.sync_info'\n\n# Get validator set\ncurl -s https://aeneid.storyrpc.io/validators | jq '.result.validators | length'\n\n# Check latest block\ncurl -s https://aeneid.storyrpc.io/block | jq '.result.block.header.height'\n```\n\n:::info\nThe Aeneid testnet is the current active testnet for Story Protocol. Make sure to use the correct chain ID (1315) for all transactions.\n:::"
        },
        {
          "id": "competition-resources",
          "title": "Competition Resources",
          "icon": "üèÖ",
          "type": "page",
          "content": "# üèÖ Competition Resources\n\n## üèÜ Story Protocol Validator Competition\n\n| Resource | Link | Description |\n|----------|------|-------------|\n| **üìä Round 1 Results** | [https://storytable.coinsspor.com](https://storytable.coinsspor.com) | Complete Round 1 Stats |\n| **üìä Round 2 Tracking** | [https://storytable.coinsspor.com/round2](https://storytable.coinsspor.com/round2) | Current Round Stats |\n\n## üìÖ Competition Timeline\n\n**üìÖ Competition Period:** June 30, 2025 - July 28, 2025  \n**üéØ Active Validators:** 80  \n**üìà Average Uptime:** 99.9%\n\n## üèÜ Key Metrics\n\n### Performance Tracking\n- **Uptime**: Percentage of blocks signed\n- **Commission**: Validator commission rate\n- **Delegations**: Total stake delegated\n- **Self-Stake**: Validator's own stake\n- **Community Score**: Social engagement\n\n### Competition Rules\n1. **Minimum Stake**: 1024 IP tokens\n2. **Uptime Requirement**: 95%+ to qualify\n3. **Geographic Distribution**: Bonus for diverse locations\n4. **Technical Excellence**: Bonus for best practices\n5. **Community Engagement**: Social media activity scoring\n\n## üìä Live Leaderboard\n\n```bash\n# Check your validator ranking\ncurl -s https://storytable.coinsspor.com/api/validator/YOUR_VALIDATOR_ADDRESS\n\n# Get top 10 validators\ncurl -s https://storytable.coinsspor.com/api/leaderboard | jq '.top10'\n```\n\n## üéØ Winning Strategies\n\n### 1. **Maximum Uptime**\n- Monitor your node 24/7\n- Set up alerting systems\n- Have backup infrastructure ready\n\n### 2. **Community Engagement**\n- Share updates on social media\n- Help other validators\n- Contribute to documentation\n\n### 3. **Technical Excellence**\n- Use monitoring tools\n- Optimize node performance\n- Follow best practices\n\n:::tip\nRegularly check the leaderboard to track your performance and identify areas for improvement!\n:::"
        }
      ]
    },
    {
      "id": "installation",
      "title": "Installation",
      "icon": "‚öôÔ∏è",
      "type": "section",
      "children": [
        {
          "id": "system-preparation",
          "title": "System Preparation",
          "icon": "üîß",
          "type": "page",
          "content": "# üîß System Preparation\n\n## Step 1: Update System Packages\n\n```bash\n# Update system packages\nsudo apt update && sudo apt upgrade -y\n\n# Install dependencies\nsudo apt install -y curl git wget htop tmux build-essential jq make lz4 gcc unzip aria2\n```\n\n## Step 2: Install Go 1.22.11\n\n```bash\ncd $HOME\nVER=\"1.22.11\"\nwget \"https://golang.org/dl/go$VER.linux-amd64.tar.gz\"\nsudo rm -rf /usr/local/go\nsudo tar -C /usr/local -xzf \"go$VER.linux-amd64.tar.gz\"\nrm \"go$VER.linux-amd64.tar.gz\"\n\n# Add to PATH\necho \"export PATH=$PATH:/usr/local/go/bin:~/go/bin\" >> ~/.bash_profile\nsource ~/.bash_profile\n\n# Verify installation\ngo version\n```\n\n## Step 3: Set Variables and Port Configuration\n\n```bash\n# Set your moniker (node name)\necho \"export STORY_MONIKER=\\\"YourNodeName\\\"\" >> $HOME/.bash_profile\n\n# Set port prefix (change this to your desired prefix, e.g., 26, 56, 62, etc.)\necho \"export STORY_PORT=\\\"26\\\"\" >> $HOME/.bash_profile\n\nsource $HOME/.bash_profile\n\n# Verify variables\necho \"Moniker: $STORY_MONIKER\"\necho \"Port Prefix: $STORY_PORT\"\n```\n\n:::warning\n**Important Port Configuration**\n\nChoose a unique port prefix if you're running multiple nodes:\n- Single node: Use `26` (default)\n- Multiple nodes: Use `56`, `66`, `76`, etc.\n- Avoid conflicts with other services\n:::\n\n## Step 4: Create Directory Structure\n\n```bash\n# Create necessary directories\nmkdir -p $HOME/.story/story\nmkdir -p $HOME/.story/geth\nmkdir -p $HOME/go/bin\n\n# Set proper permissions\nchmod 755 $HOME/.story\nchmod 755 $HOME/go/bin\n```\n\n## ‚úÖ Verification Checklist\n\n- [ ] System packages updated\n- [ ] Go 1.22.11 installed and in PATH\n- [ ] Environment variables set\n- [ ] Directory structure created\n- [ ] No port conflicts\n\n```bash\n# Run verification script\necho \"üîç System Verification\"\necho \"===================\"\necho \"Go Version: $(go version)\"\necho \"Moniker: $STORY_MONIKER\"\necho \"Port Prefix: $STORY_PORT\"\necho \"Home Directory: $HOME\"\necho \"===================\"\n```"
        },
        {
          "id": "install-binaries",
          "title": "Install Binaries",
          "icon": "üì¶",
          "type": "page",
          "content": "# üì¶ Install Binaries\n\n## Step 1: Install Story-Geth (Execution Client)\n\n```bash\ncd $HOME\nrm -rf story-geth\ngit clone https://github.com/piplabs/story-geth.git\ncd story-geth\ngit checkout v1.1.1\ngo build -v ./cmd/geth\nmv ./geth $HOME/go/bin/story-geth\n\n# Verify installation\nstory-geth version\n```\n\n## Step 2: Install Story (Consensus Client)\n\n```bash\ncd $HOME\nrm -rf story\ngit clone https://github.com/piplabs/story\ncd story\ngit checkout v1.3.0\ngo build -o story ./client \nmv ./story $HOME/go/bin/story\n\n# Verify installation\nstory version\n```\n\n## Step 3: Initialize Node\n\n```bash\n# Initialize the node\nstory init --moniker $STORY_MONIKER --network aeneid\n\n# Verify initialization\nls -la $HOME/.story/story/config/\n```\n\n## ‚ö†Ô∏è **Important: Why Build from Source?**\n\n**Pre-compiled binaries on GitHub are built with Ubuntu 24.04** and may not work properly on Ubuntu 22.04 due to library dependencies. **Building from source ensures compatibility** with your system.\n\n### ‚ùå **Pre-compiled Binaries Issue**\n- Built for Ubuntu 24.04\n- Different glibc versions\n- Library dependency conflicts\n- May cause crashes or failures\n\n### ‚úÖ **Build from Source (Required for Ubuntu 22.04)**\n- **Full compatibility** with your system\n- **Correct library linking**\n- **Stable operation**\n- **No dependency issues**\n\n## üîç Version Verification\n\n```bash\n# Check installed versions\necho \"üì¶ Installed Versions:\"\necho \"==================\"\necho \"Story-Geth: $(story-geth version | head -1)\"\necho \"Story: $(story version)\"\necho \"Go: $(go version)\"\necho \"==================\"\n\n# Check binary locations\nwhich story\nwhich story-geth\n```\n\n## üßπ Cleanup (Optional)\n\n```bash\n# Remove source directories to save space\ncd $HOME\nrm -rf story\nrm -rf story-geth\n\necho \"‚úÖ Source directories cleaned up\"\n```\n\n:::tip\nKeep the source directories if you plan to build custom versions or contribute to development.\n:::"
        }
      ]
    },
    {
      "id": "cosmovisor-setup",
      "title": "Cosmovisor Setup",
      "icon": "üîÑ",
      "type": "section",
      "children": [
        {
          "id": "install-cosmovisor",
          "title": "Install Cosmovisor",
          "icon": "üì•",
          "type": "page",
          "content": "# üì• Install Cosmovisor\n\n## What is Cosmovisor?\n\nCosmovisor is a process manager for Cosmos SDK applications that automates upgrades. It monitors governance proposals and automatically switches to new binary versions when upgrade heights are reached.\n\n## Benefits\n- **Zero-downtime upgrades**: Automatic binary switching\n- **Rollback support**: Revert to previous versions if needed\n- **Backup creation**: Automatic data backups before upgrades\n- **Monitoring**: Detailed upgrade logs and status\n\n## Step 1: Install Cosmovisor\n\n```bash\n# Install Cosmovisor\ngo install cosmossdk.io/tools/cosmovisor/cmd/cosmovisor@v1.6.0\n\n# Verify installation\ncosmovisor version\n```\n\n## Step 2: Configure Environment Variables\n\n```bash\n# Set environment variables\necho \"export DAEMON_NAME=story\" >> $HOME/.bash_profile\necho \"export DAEMON_HOME=$HOME/.story/story\" >> $HOME/.bash_profile\necho \"export DAEMON_DATA_BACKUP_DIR=$DAEMON_HOME/cosmovisor/backup\" >> $HOME/.bash_profile\necho \"export DAEMON_ALLOW_DOWNLOAD_BINARIES=false\" >> $HOME/.bash_profile\necho \"export DAEMON_RESTART_AFTER_UPGRADE=true\" >> $HOME/.bash_profile\n\nsource $HOME/.bash_profile\n```\n\n## Step 3: Initialize Cosmovisor\n\n```bash\n# Initialize cosmovisor with story binary\ncosmovisor init $(which story)\n\n# Create backup directory\nmkdir -p $DAEMON_HOME/cosmovisor/backup\n\n# Set proper permissions\nsudo chown -R $USER:$USER $HOME/.story\n```\n\n## üìÅ Directory Structure\n\nAfter initialization, your directory structure should look like:\n\n```\n~/.story/story/cosmovisor/\n‚îú‚îÄ‚îÄ current -> genesis\n‚îú‚îÄ‚îÄ genesis/\n‚îÇ   ‚îî‚îÄ‚îÄ bin/\n‚îÇ       ‚îî‚îÄ‚îÄ story\n‚îú‚îÄ‚îÄ upgrades/\n‚îî‚îÄ‚îÄ backup/\n```\n\n## ‚úÖ Verification\n\n```bash\n# Check cosmovisor setup\necho \"üîç Cosmovisor Verification\"\necho \"==========================\"\necho \"Current binary: $(ls -la $DAEMON_HOME/cosmovisor/current)\"\necho \"Genesis binary: $(ls -la $DAEMON_HOME/cosmovisor/genesis/bin/)\"\necho \"Backup directory: $(ls -la $DAEMON_HOME/cosmovisor/backup)\"\necho \"==========================\"\n\n# Test cosmovisor\ncosmovisor run version\n```"
        },
        {
          "id": "cosmovisor-configuration",
          "title": "Advanced Configuration",
          "icon": "‚öôÔ∏è",
          "type": "page",
          "content": "# ‚öôÔ∏è Advanced Cosmovisor Configuration\n\n## Environment Variables Explained\n\n| Variable | Description | Recommended Value |\n|----------|-------------|-------------------|\n| `DAEMON_NAME` | Name of the binary | `story` |\n| `DAEMON_HOME` | Home directory for the daemon | `$HOME/.story/story` |\n| `DAEMON_ALLOW_DOWNLOAD_BINARIES` | Auto-download binaries from URL | `false` (security) |\n| `DAEMON_RESTART_AFTER_UPGRADE` | Restart after upgrade | `true` |\n| `DAEMON_POLL_INTERVAL` | Check for upgrades interval | `300ms` (default) |\n| `DAEMON_DATA_BACKUP_DIR` | Backup directory | `$DAEMON_HOME/cosmovisor/backup` |\n| `UNSAFE_SKIP_BACKUP` | Skip data backup | `false` |\n\n## Optional Advanced Settings\n\n```bash\n# Advanced cosmovisor configuration (optional)\necho \"export DAEMON_POLL_INTERVAL=300ms\" >> $HOME/.bash_profile\necho \"export UNSAFE_SKIP_BACKUP=false\" >> $HOME/.bash_profile\necho \"export DAEMON_PREUPGRADE_MAX_RETRIES=3\" >> $HOME/.bash_profile\n\nsource $HOME/.bash_profile\n```\n\n## Backup Configuration\n\n```bash\n# Configure automatic backups\nmkdir -p $DAEMON_HOME/cosmovisor/backup\n\n# Set backup retention (optional script)\ncat > $HOME/cleanup_backups.sh << 'EOF'\n#!/bin/bash\n# Keep only last 5 backups\nfind $DAEMON_HOME/cosmovisor/backup -maxdepth 1 -type d -name \"*\" | sort -r | tail -n +6 | xargs rm -rf\nEOF\n\nchmod +x $HOME/cleanup_backups.sh\n```\n\n## Upgrade Testing\n\n```bash\n# Test cosmovisor with dry run\ncosmovisor run start --help\n\n# Check current version\ncosmovisor run version\n\n# View cosmovisor configuration\nenv | grep DAEMON\n```\n\n## üîß Troubleshooting Cosmovisor\n\n### Common Issues\n\n**1. Binary not found**\n```bash\n# Check if binary exists\nls -la $DAEMON_HOME/cosmovisor/current/bin/story\n\n# Reinitialize if needed\ncosmovisor init $(which story)\n```\n\n**2. Permission errors**\n```bash\n# Fix permissions\nsudo chown -R $USER:$USER $HOME/.story\nchmod +x $DAEMON_HOME/cosmovisor/current/bin/story\n```\n\n**3. Environment variables not set**\n```bash\n# Check variables\necho \"DAEMON_NAME: $DAEMON_NAME\"\necho \"DAEMON_HOME: $DAEMON_HOME\"\n\n# Reload if needed\nsource $HOME/.bash_profile\n```\n\n## üìä Monitoring Cosmovisor\n\n```bash\n# Create monitoring script\ncat > $HOME/cosmovisor_status.sh << 'EOF'\n#!/bin/bash\necho \"üîç Cosmovisor Status\"\necho \"==================\"\necho \"Current Version: $(cosmovisor run version 2>/dev/null)\"\necho \"Binary Path: $(readlink -f $DAEMON_HOME/cosmovisor/current/bin/story)\"\necho \"Upgrades Available: $(ls $DAEMON_HOME/cosmovisor/upgrades/ 2>/dev/null | wc -l)\"\necho \"Backup Directory: $(du -sh $DAEMON_HOME/cosmovisor/backup 2>/dev/null | cut -f1)\"\necho \"==================\"\nEOF\n\nchmod +x $HOME/cosmovisor_status.sh\n```\n\n:::info\nCosmovisor automatically handles upgrades when they're scheduled via governance proposals. Manual intervention is rarely needed.\n:::"
        }
      ]
    },
    {
      "id": "configuration",
      "title": "Configuration",
      "icon": "‚öôÔ∏è",
      "type": "section",
      "children": [
        {
          "id": "port-configuration",
          "title": "Port Configuration",
          "icon": "üîå",
          "type": "page",
          "content": "# üîå Port Configuration\n\n## Dynamic Port Setup\n\nStory Protocol uses multiple services that need different ports. Our dynamic configuration allows you to run multiple nodes on the same server without conflicts.\n\n## Step 1: Configure Story Ports\n\n```bash\n# Configure Story ports using your prefix\nsed -i.bak -e \"s%:1317%:${STORY_PORT}317%g;\ns%:8551%:${STORY_PORT}551%g\" $HOME/.story/story/config/story.toml\n\nsed -i.bak -e \"s%:26658%:${STORY_PORT}658%g;\ns%:26657%:${STORY_PORT}657%g;\ns%:26656%:${STORY_PORT}656%g;\ns%^external_address = \\\"\\\"%external_address = \\\"$(wget -qO- eth0.me):${STORY_PORT}656\\\"%;\ns%:26660%:${STORY_PORT}660%g\" $HOME/.story/story/config/config.toml\n\necho \"‚úÖ Configured ports with prefix: $STORY_PORT\"\necho \"üåê RPC Port: ${STORY_PORT}657\"\necho \"üîó P2P Port: ${STORY_PORT}656\"\necho \"üì° API Port: ${STORY_PORT}317\"\n```\n\n## Port Reference Table\n\n| Service | Default Port | Your Port (prefix=${STORY_PORT}) | Purpose |\n|---------|--------------|----------------------------------|----------|\n| **Story P2P** | 26656 | ${STORY_PORT}656 | Peer-to-peer communication |\n| **Story RPC** | 26657 | ${STORY_PORT}657 | RPC API endpoint |\n| **Story API** | 26317 | ${STORY_PORT}317 | REST API endpoint |\n| **Story Prometheus** | 26660 | ${STORY_PORT}660 | Metrics endpoint |\n| **Story-Geth P2P** | 26303 | ${STORY_PORT}303 | Geth P2P |\n| **Story-Geth RPC** | 26545 | ${STORY_PORT}545 | Geth RPC |\n| **Story-Geth WS** | 26546 | ${STORY_PORT}546 | Geth WebSocket |\n| **Story-Geth Auth** | 26551 | ${STORY_PORT}551 | Geth Engine API |\n| **Story-Geth Metrics** | 26060 | ${STORY_PORT}060 | Geth Metrics |\n\n## Step 2: Verify Port Configuration\n\n```bash\n# Check configured ports\necho \"üìä Port Configuration Summary\"\necho \"============================\"\ngrep -E \"(laddr|proxy_app|prometheus)\" $HOME/.story/story/config/config.toml | head -5\ngrep -E \"(api_address)\" $HOME/.story/story/config/story.toml\necho \"============================\"\n```\n\n## Step 3: Firewall Configuration\n\n```bash\n# Configure UFW firewall (if enabled)\nsudo ufw allow ${STORY_PORT}656/tcp  # P2P\nsudo ufw allow ${STORY_PORT}657/tcp  # RPC\nsudo ufw allow ${STORY_PORT}317/tcp  # API\nsudo ufw allow ${STORY_PORT}303/tcp  # Geth P2P\nsudo ufw allow ${STORY_PORT}545/tcp  # Geth RPC\nsudo ufw allow ${STORY_PORT}546/tcp  # Geth WS\n\n# Check UFW status\nsudo ufw status\n```\n\n## üîç Port Conflict Detection\n\n```bash\n# Check for port conflicts\necho \"üîç Checking for port conflicts...\"\nfor port in \"${STORY_PORT}656\" \"${STORY_PORT}657\" \"${STORY_PORT}317\" \"${STORY_PORT}545\"; do\n    if netstat -tuln | grep -q \":$port \"; then\n        echo \"‚ö†Ô∏è  Port $port is already in use\"\n        netstat -tuln | grep \":$port \"\n    else\n        echo \"‚úÖ Port $port is available\"\n    fi\ndone\n```\n\n## üåê External Address Configuration\n\nThe configuration automatically sets your external IP address. You can verify this:\n\n```bash\n# Check external address setting\ngrep \"external_address\" $HOME/.story/story/config/config.toml\n\n# Verify your public IP\ncurl -s eth0.me\nwget -qO- ifconfig.me\n```\n\n:::warning\n**Important Notes:**\n- Choose a unique port prefix for each node\n- Common prefixes: 26 (default), 56, 66, 76, 86, 96\n- Avoid system ports (1-1024)\n- Document your port assignments\n:::"
        },
        {
          "id": "network-configuration",
          "title": "Network Configuration",
          "icon": "üåê",
          "type": "page",
          "content": "# üåê Network Configuration\n\n## Step 1: Configure Seeds and Peers\n\n```bash\nSEEDS=\"944e8889ecd7c13623ef1081aae4555d6f525041@b1-b.odyssey-devnet.storyrpc.io:26656\"\nPEERS=\"3b1aaa03f996d619cb2f4230ebace45686ab3b8a@34.140.167.127:26656,36ca8b119bf5851cd1e37060af914cb07dec24f9@34.79.40.193:26656,2a28bd1a6ecb0a1d8ceade599b311d202447d635@193.122.141.78:26656\"\n\nsed -i -e \"/^\\[p2p\\]/,/^\\[/{s/^[[:space:]]*seeds *=.*/seeds = \\\"$SEEDS\\\"/}\" \\\n       -e \"/^\\[p2p\\]/,/^\\[/{s/^[[:space:]]*persistent_peers *=.*/persistent_peers = \\\"$PEERS\\\"/}\" $HOME/.story/story/config/config.toml\n```\n\n## üçÄ Fresh Peers Discovery (Recommended)\n\nFor better connectivity and faster sync, use our fresh peer discovery system:\n\n```bash\n# Get fresh peers from Coinsspor RPC\nURL=\"https://story-aeneid-testnet-rpc.coinsspor.com/net_info\"\n\necho \"üîç Discovering fresh peers from Coinsspor RPC...\"\nresponse=$(curl -s $URL)\n\n# Extract active peers with valid IP addresses\nPEERS=$(echo $response | jq -r '.result.peers[] | select(.remote_ip | test(\"^[0-9]{1,3}(\\\\.[0-9]{1,3}){3}$\")) | \"\\(.node_info.id)@\\(.remote_ip):\" + (.node_info.listen_addr | capture(\":(?<port>[0-9]+)$\").port)' | paste -sd \",\" -)\n\nif [ -n \"$PEERS\" ]; then\n    echo \"‚úÖ Found fresh peers: $PEERS\"\n    echo \"üîß Updating config.toml with fresh peers...\"\n    \n    # Update persistent_peers in config.toml\n    sed -i 's|^persistent_peers *=.*|persistent_peers = \"'$PEERS'\"|' $HOME/.story/story/config/config.toml\n    \n    echo \"‚úÖ Fresh peers configured successfully!\"\nelse\n    echo \"‚ö†Ô∏è  No fresh peers found, using default peers\"\nfi\n```\n\n## Step 2: Advanced Network Settings\n\n```bash\n# Configure additional network settings\nsed -i -e \"s/max_num_inbound_peers = 40/max_num_inbound_peers = 100/g\" $HOME/.story/story/config/config.toml\nsed -i -e \"s/max_num_outbound_peers = 10/max_num_outbound_peers = 50/g\" $HOME/.story/story/config/config.toml\nsed -i -e \"s/flush_throttle_timeout = \\\"100ms\\\"/flush_throttle_timeout = \\\"10ms\\\"/g\" $HOME/.story/story/config/config.toml\n```\n\n## Step 3: Configure Indexer and Prometheus\n\n```bash\n# Enable Prometheus and disable indexer for better performance\nsed -i -e \"s/prometheus = false/prometheus = true/\" $HOME/.story/story/config/config.toml\nsed -i -e \"s/^indexer *=.*/indexer = \\\"null\\\"/\" $HOME/.story/story/config/config.toml\n```\n\n## üîÑ Fresh Peers Management Script\n\n```bash\n# Create fresh peers function for easy use\ncat > $HOME/get_fresh_peers.sh << 'EOF'\n#!/bin/bash\n\nget_fresh_peers() {\n    echo \"üîç Fetching fresh peers from Coinsspor RPC...\"\n    URL=\"https://story-aeneid-testnet-rpc.coinsspor.com/net_info\"\n    response=$(curl -s $URL)\n    \n    if [ -z \"$response\" ]; then\n        echo \"‚ùå Failed to connect to RPC endpoint\"\n        return 1\n    fi\n    \n    PEERS=$(echo $response | jq -r '.result.peers[] | select(.remote_ip | test(\"^[0-9]{1,3}(\\\\.[0-9]{1,3}){3}$\")) | \"\\(.node_info.id)@\\(.remote_ip):\" + (.node_info.listen_addr | capture(\":(?<port>[0-9]+)$\").port)' | paste -sd \",\" -)\n    \n    if [ -n \"$PEERS\" ]; then\n        echo \"‚úÖ Fresh peers found:\"\n        echo \"$PEERS\" | tr ',' '\\n' | head -10  # Show first 10 peers\n        echo \"\"\n        echo \"üîß Apply these peers? (y/n)\"\n        read -r apply_peers\n        \n        if [ \"$apply_peers\" = \"y\" ] || [ \"$apply_peers\" = \"Y\" ]; then\n            sed -i 's|^persistent_peers *=.*|persistent_peers = \"'$PEERS'\"|' $HOME/.story/story/config/config.toml\n            sudo systemctl restart story\n            echo \"‚úÖ Fresh peers applied and service restarted!\"\n            \n            # Check connection after restart\n            sleep 10\n            peer_count=$(curl -s localhost:${STORY_PORT}657/net_info | jq '.result.n_peers')\n            echo \"üìä Connected to $peer_count peers\"\n        fi\n    else\n        echo \"‚ùå No fresh peers found\"\n    fi\n}\n\n# Run the function\nget_fresh_peers\nEOF\n\nchmod +x $HOME/get_fresh_peers.sh\necho \"‚úÖ Fresh peers script created: $HOME/get_fresh_peers.sh\"\n```\n\n## üîç Network Diagnostics\n\n```bash\n# Network diagnostic script\ncat > $HOME/network_diagnostics.sh << 'EOF'\n#!/bin/bash\n\necho \"üåê Network Diagnostics\"\necho \"====================\\n\"\n\n# Check peer connections\nPEER_COUNT=$(curl -s localhost:${STORY_PORT}657/net_info | jq '.result.n_peers')\necho \"üìä Connected Peers: $PEER_COUNT\"\n\n# Check sync status\nSYNC_INFO=$(curl -s localhost:${STORY_PORT}657/status | jq '.result.sync_info')\nCATCHING_UP=$(echo $SYNC_INFO | jq -r '.catching_up')\nLATEST_HEIGHT=$(echo $SYNC_INFO | jq -r '.latest_block_height')\n\necho \"üìà Latest Height: $LATEST_HEIGHT\"\necho \"üîÑ Catching Up: $CATCHING_UP\"\n\n# Check network connectivity\necho \"\\nüîç Testing Network Connectivity:\"\ncurl -s --max-time 5 https://aeneid.storyrpc.io/status >/dev/null && echo \"‚úÖ Official RPC: OK\" || echo \"‚ùå Official RPC: Failed\"\ncurl -s --max-time 5 https://story-aeneid-testnet-rpc.coinsspor.com/status >/dev/null && echo \"‚úÖ Coinsspor RPC: OK\" || echo \"‚ùå Coinsspor RPC: Failed\"\n\necho \"====================\\n\"\nEOF\n\nchmod +x $HOME/network_diagnostics.sh\n```"
        },
        {
          "id": "genesis-addrbook",
          "title": "Genesis & Addrbook",
          "icon": "üìã",
          "type": "page",
          "content": "# üìã Genesis & Addrbook Configuration\n\n## Step 1: Download Genesis File\n\n```bash\n# Download genesis file from Coinsspor GitHub\nwget -O $HOME/.story/story/config/genesis.json https://raw.githubusercontent.com/coinsspor/Story-Aeneid/refs/heads/main/genesis.json\n```\n\n## Step 2: Download Addrbook\n\n```bash\n# Download addrbook for faster peer discovery\nwget -O $HOME/.story/story/config/addrbook.json https://raw.githubusercontent.com/coinsspor/Story-Aeneid/refs/heads/main/addrbook.json\n```\n\n## Step 3: Verify Downloads\n\n```bash\n# Verify files are downloaded correctly\necho \"‚úÖ Verifying downloaded files...\"\n\nif [ -f \"$HOME/.story/story/config/genesis.json\" ]; then\n    genesis_size=$(stat -c%s \"$HOME/.story/story/config/genesis.json\")\n    echo \"‚úÖ Genesis file downloaded successfully (Size: $genesis_size bytes)\"\nelse\n    echo \"‚ùå Genesis download failed\"\n    exit 1\nfi\n\nif [ -f \"$HOME/.story/story/config/addrbook.json\" ]; then\n    addrbook_size=$(stat -c%s \"$HOME/.story/story/config/addrbook.json\")\n    echo \"‚úÖ Addrbook downloaded successfully (Size: $addrbook_size bytes)\"\nelse\n    echo \"‚ö†Ô∏è  Addrbook download failed - node will discover peers automatically\"\nfi\n\n# Set proper permissions\nchmod 644 $HOME/.story/story/config/genesis.json\nchmod 644 $HOME/.story/story/config/addrbook.json\n\necho \"‚úÖ Genesis and addrbook setup completed\"\n```\n\n## üîç Genesis File Validation\n\n```bash\n# Validate genesis file\necho \"üîç Validating genesis file...\"\n\n# Check if it's valid JSON\nif jq empty $HOME/.story/story/config/genesis.json 2>/dev/null; then\n    echo \"‚úÖ Genesis file is valid JSON\"\nelse\n    echo \"‚ùå Genesis file is invalid JSON\"\n    exit 1\nfi\n\n# Extract key information\nCHAIN_ID=$(jq -r '.chain_id' $HOME/.story/story/config/genesis.json)\nGENESIS_TIME=$(jq -r '.genesis_time' $HOME/.story/story/config/genesis.json)\nINITIAL_HEIGHT=$(jq -r '.initial_height' $HOME/.story/story/config/genesis.json)\n\necho \"üìä Genesis Information:\"\necho \"Chain ID: $CHAIN_ID\"\necho \"Genesis Time: $GENESIS_TIME\"\necho \"Initial Height: $INITIAL_HEIGHT\"\n```\n\n## üîß Alternative Download Methods\n\n### Method 1: Direct from Official Source\n```bash\n# Download from official repository (alternative)\nwget -O $HOME/.story/story/config/genesis.json https://raw.githubusercontent.com/piplabs/story/main/networks/aeneid/genesis.json\n```\n\n### Method 2: Using Curl with Retry\n```bash\n# Download with retry logic\nfor i in {1..3}; do\n    echo \"Download attempt $i/3...\"\n    if curl -L --fail -o $HOME/.story/story/config/genesis.json https://raw.githubusercontent.com/coinsspor/Story-Aeneid/refs/heads/main/genesis.json; then\n        echo \"‚úÖ Genesis downloaded successfully\"\n        break\n    else\n        echo \"‚ùå Download failed, retrying...\"\n        sleep 5\n    fi\ndone\n```\n\n## üìä Addrbook Management\n\n```bash\n# Check addrbook content\necho \"üìä Addrbook Statistics:\"\nif [ -f \"$HOME/.story/story/config/addrbook.json\" ]; then\n    PEER_COUNT=$(jq '.addrs | length' $HOME/.story/story/config/addrbook.json 2>/dev/null || echo \"0\")\n    echo \"Known peers in addrbook: $PEER_COUNT\"\n    \n    # Show sample peers\n    echo \"Sample peers:\"\n    jq -r '.addrs | keys | .[:5][]' $HOME/.story/story/config/addrbook.json 2>/dev/null | head -5\nelse\n    echo \"No addrbook file found\"\nfi\n```\n\n## üîÑ Reset Configuration (if needed)\n\n```bash\n# Reset genesis and addrbook (if corrupted)\nreset_genesis_config() {\n    echo \"üîÑ Resetting genesis configuration...\"\n    \n    # Backup existing files\n    if [ -f \"$HOME/.story/story/config/genesis.json\" ]; then\n        cp $HOME/.story/story/config/genesis.json $HOME/.story/story/config/genesis.json.backup\n    fi\n    \n    if [ -f \"$HOME/.story/story/config/addrbook.json\" ]; then\n        cp $HOME/.story/story/config/addrbook.json $HOME/.story/story/config/addrbook.json.backup\n    fi\n    \n    # Re-download files\n    wget -O $HOME/.story/story/config/genesis.json https://raw.githubusercontent.com/coinsspor/Story-Aeneid/refs/heads/main/genesis.json\n    wget -O $HOME/.story/story/config/addrbook.json https://raw.githubusercontent.com/coinsspor/Story-Aeneid/refs/heads/main/addrbook.json\n    \n    echo \"‚úÖ Genesis configuration reset completed\"\n}\n\n# Uncomment to run: reset_genesis_config\n```\n\n:::info\n**Genesis File Purpose:**\n- Contains initial network state\n- Defines consensus parameters\n- Sets initial validator set\n- Must match exactly across all nodes\n\n**Addrbook Purpose:**\n- Contains known peer addresses\n- Speeds up peer discovery\n- Reduces initial sync time\n- Updates automatically during operation\n:::"
        }
      ]
    },
    {
      "id": "services",
      "title": "System Services",
      "icon": "üîß",
      "type": "section",
      "children": [
        {
          "id": "story-geth-service",
          "title": "Story-Geth Service",
          "icon": "‚ö°",
          "type": "page",
          "content": "# ‚ö° Story-Geth Service\n\n## Create Story-Geth Service\n\n```bash\nsudo tee /etc/systemd/system/story-geth.service > /dev/null <<EOF\n[Unit]\nDescription=Story Geth Client\nAfter=network-online.target\n\n[Service]\nUser=$USER\nExecStart=$HOME/go/bin/story-geth --aeneid --syncmode full --port ${STORY_PORT}303 --http --http.api eth,net,web3,engine --http.vhosts '*' --http.addr 0.0.0.0 --http.port ${STORY_PORT}545 --authrpc.addr 127.0.0.1 --authrpc.port ${STORY_PORT}551 --authrpc.vhosts=* --ws --ws.api eth,web3,net,txpool --ws.addr 0.0.0.0 --ws.port ${STORY_PORT}546 --ws.origins '*' --metrics --metrics.addr 0.0.0.0 --metrics.port ${STORY_PORT}060\nRestart=on-failure\nRestartSec=3\nLimitNOFILE=65535\n\n[Install]\nWantedBy=multi-user.target\nEOF\n```\n\n## Service Configuration Explained\n\n### Command Line Arguments\n\n| Argument | Purpose | Value |\n|----------|---------|-------|\n| `--aeneid` | Connect to Aeneid testnet | - |\n| `--syncmode full` | Full synchronization mode | Recommended |\n| `--port` | P2P port | ${STORY_PORT}303 |\n| `--http` | Enable HTTP RPC | Required |\n| `--http.api` | Available APIs | eth,net,web3,engine |\n| `--http.addr` | HTTP bind address | 0.0.0.0 (all interfaces) |\n| `--http.port` | HTTP RPC port | ${STORY_PORT}545 |\n| `--authrpc.addr` | Auth RPC address | 127.0.0.1 (localhost only) |\n| `--authrpc.port` | Auth RPC port | ${STORY_PORT}551 |\n| `--ws` | Enable WebSocket | Required |\n| `--ws.api` | WebSocket APIs | eth,web3,net,txpool |\n| `--ws.addr` | WebSocket address | 0.0.0.0 |\n| `--ws.port` | WebSocket port | ${STORY_PORT}546 |\n| `--metrics` | Enable metrics | For monitoring |\n| `--metrics.port` | Metrics port | ${STORY_PORT}060 |\n\n### Security Considerations\n\n- **Auth RPC**: Bound to localhost only (127.0.0.1)\n- **HTTP/WS APIs**: Limited to safe methods\n- **CORS**: Configured for development use\n- **File Limits**: Increased to 65535\n\n## üîç Verify Service Configuration\n\n```bash\n# Check service file\nsudo systemctl cat story-geth.service\n\n# Validate systemd syntax\nsudo systemd-analyze verify /etc/systemd/system/story-geth.service\n\n# Check if user exists and has permissions\necho \"Service user: $USER\"\nls -la $HOME/go/bin/story-geth\n```\n\n## üöÄ Service Management Commands\n\n```bash\n# Reload systemd configuration\nsudo systemctl daemon-reload\n\n# Enable service (start on boot)\nsudo systemctl enable story-geth\n\n# Start service\nsudo systemctl start story-geth\n\n# Check status\nsudo systemctl status story-geth\n\n# View logs\nsudo journalctl -u story-geth -f\n\n# Stop service\nsudo systemctl stop story-geth\n\n# Restart service\nsudo systemctl restart story-geth\n```\n\n## üìä Service Monitoring\n\n```bash\n# Check if service is running\nsudo systemctl is-active story-geth\n\n# Check if service is enabled\nsudo systemctl is-enabled story-geth\n\n# View recent logs\nsudo journalctl -u story-geth -n 50 --no-pager\n\n# Monitor real-time logs\nsudo journalctl -u story-geth -f\n```\n\n## üîß Advanced Service Configuration\n\n### Resource Limits\n```bash\n# Optional: Set resource limits\nsudo mkdir -p /etc/systemd/system/story-geth.service.d\nsudo tee /etc/systemd/system/story-geth.service.d/limits.conf > /dev/null <<EOF\n[Service]\nLimitNOFILE=1048576\nLimitNPROC=1048576\nEOF\n\nsudo systemctl daemon-reload\n```\n\n### Environment Variables\n```bash\n# Optional: Add environment variables\nsudo tee /etc/systemd/system/story-geth.service.d/environment.conf > /dev/null <<EOF\n[Service]\nEnvironment=\"GOMAXPROCS=8\"\nEnvironment=\"GOGC=100\"\nEOF\n\nsudo systemctl daemon-reload\n```\n\n## üÜò Troubleshooting\n\n### Common Issues\n\n**Service fails to start:**\n```bash\n# Check logs for errors\nsudo journalctl -u story-geth --since \"5 minutes ago\"\n\n# Verify binary exists and is executable\nls -la $HOME/go/bin/story-geth\nfile $HOME/go/bin/story-geth\n\n# Test binary manually\n$HOME/go/bin/story-geth version\n```\n\n**Port conflicts:**\n```bash\n# Check if ports are in use\nsudo netstat -tuln | grep ${STORY_PORT}545\nsudo netstat -tuln | grep ${STORY_PORT}303\n\n# Kill conflicting processes\nsudo lsof -ti:${STORY_PORT}545 | xargs sudo kill -9\n```\n\n**Permission errors:**\n```bash\n# Fix ownership\nsudo chown $USER:$USER $HOME/go/bin/story-geth\nchmod +x $HOME/go/bin/story-geth\n\n# Check home directory permissions\nls -la $HOME/.story/\n```\n\n:::warning\n**Important Notes:**\n- Story-Geth must start before Story consensus client\n- Keep the auth RPC port (${STORY_PORT}551) secure\n- Monitor disk space as blockchain data grows\n- Regular log rotation is recommended\n:::"
        },
        {
          "id": "story-service",
          "title": "Story Service with Cosmovisor",
          "icon": "üèóÔ∏è",
          "type": "page",
          "content": "# üèóÔ∏è Story Service with Cosmovisor\n\n## Create Story Service\n\n```bash\nsudo tee /etc/systemd/system/story.service > /dev/null <<EOF\n[Unit]\nDescription=Story Cosmovisor\nAfter=network.target\n\n[Service]\nType=simple\nUser=$USER\nExecStart=$HOME/go/bin/cosmovisor run run --api-enable --api-address=0.0.0.0:${STORY_PORT}317\nRestart=on-failure\nRestartSec=5\nLimitNOFILE=65535\nEnvironment=\"DAEMON_NAME=story\"\nEnvironment=\"DAEMON_HOME=$HOME/.story/story\"\nEnvironment=\"DAEMON_ALLOW_DOWNLOAD_BINARIES=false\"\nEnvironment=\"DAEMON_RESTART_AFTER_UPGRADE=true\"\nEnvironment=\"DAEMON_DATA_BACKUP_DIR=$HOME/.story/story/cosmovisor/backup\"\nWorkingDirectory=$HOME/.story/story\n\n[Install]\nWantedBy=multi-user.target\nEOF\n```\n\n## Service Configuration Breakdown\n\n### Cosmovisor Arguments\n\n| Argument | Purpose | Configuration |\n|----------|---------|---------------|\n| `run run` | Execute story with cosmovisor | Required |\n| `--api-enable` | Enable REST API | For queries |\n| `--api-address` | API bind address | 0.0.0.0:${STORY_PORT}317 |\n\n### Environment Variables\n\n| Variable | Purpose | Value |\n|----------|---------|-------|\n| `DAEMON_NAME` | Binary name | story |\n| `DAEMON_HOME` | Home directory | $HOME/.story/story |\n| `DAEMON_ALLOW_DOWNLOAD_BINARIES` | Auto-download | false (security) |\n| `DAEMON_RESTART_AFTER_UPGRADE` | Auto-restart | true |\n| `DAEMON_DATA_BACKUP_DIR` | Backup location | cosmovisor/backup |\n\n### SystemD Settings\n\n| Setting | Purpose | Value |\n|---------|---------|-------|\n| `Type=simple` | Service type | Standard process |\n| `Restart=on-failure` | Restart policy | On crashes only |\n| `RestartSec=5` | Restart delay | 5 seconds |\n| `LimitNOFILE=65535` | File descriptor limit | Increased limit |\n| `WorkingDirectory` | Execution directory | $HOME/.story/story |\n\n## üîß Service Management\n\n```bash\n# Reload systemd and enable services\nsudo systemctl daemon-reload\nsudo systemctl enable story\n\n# Start the service\nsudo systemctl start story\n\n# Check status\nsudo systemctl status story\n\n# View logs\nsudo journalctl -u story -f\n```\n\n## üìä Service Monitoring\n\n```bash\n# Create comprehensive monitoring script\ncat > $HOME/service_monitor.sh << 'EOF'\n#!/bin/bash\n\necho \"üîß Story Services Monitor\"\necho \"========================\"\n\n# Check service status\nSTORY_STATUS=$(systemctl is-active story)\nGETH_STATUS=$(systemctl is-active story-geth)\n\necho \"üìä Service Status:\"\necho \"Story: $STORY_STATUS\"\necho \"Story-Geth: $GETH_STATUS\"\n\n# Check process details\necho \"\\nüîç Process Information:\"\nps aux | grep -E \"(story|geth)\" | grep -v grep\n\n# Check ports\necho \"\\nüîå Port Status:\"\nfor port in \"${STORY_PORT}657\" \"${STORY_PORT}545\" \"${STORY_PORT}317\"; do\n    if netstat -tuln | grep -q \":$port \"; then\n        echo \"‚úÖ Port $port: Active\"\n    else\n        echo \"‚ùå Port $port: Not active\"\n    fi\ndone\n\n# Check recent logs for errors\necho \"\\n‚ö†Ô∏è  Recent Errors:\"\necho \"Story errors:\"\nsudo journalctl -u story --since \"10 minutes ago\" | grep -i error | tail -3\necho \"Geth errors:\"\nsudo journalctl -u story-geth --since \"10 minutes ago\" | grep -i error | tail -3\n\necho \"========================\"\nEOF\n\nchmod +x $HOME/service_monitor.sh\n```\n\n## üöÄ Start Services in Correct Order\n\n```bash\n# Start story-geth first (execution layer)\nsudo systemctl start story-geth\n\n# Wait for geth to initialize\necho \"‚è≥ Waiting for Story-Geth to initialize...\"\nsleep 10\n\n# Verify geth is running\nif sudo systemctl is-active --quiet story-geth; then\n    echo \"‚úÖ Story-Geth is running\"\n    \n    # Start story (consensus layer)\n    sudo systemctl start story\n    \n    # Wait and verify\n    sleep 5\n    if sudo systemctl is-active --quiet story; then\n        echo \"‚úÖ Story is running\"\n        echo \"üéâ All services started successfully!\"\n    else\n        echo \"‚ùå Story failed to start\"\n    fi\nelse\n    echo \"‚ùå Story-Geth failed to start\"\nfi\n```\n\n## üîç Service Validation\n\n```bash\n# Comprehensive service validation\nvalidate_services() {\n    echo \"üîç Validating Story Services\"\n    echo \"============================\"\n    \n    # Check if services are enabled\n    echo \"üìã Service Enable Status:\"\n    systemctl is-enabled story && echo \"‚úÖ Story: Enabled\" || echo \"‚ùå Story: Disabled\"\n    systemctl is-enabled story-geth && echo \"‚úÖ Story-Geth: Enabled\" || echo \"‚ùå Story-Geth: Disabled\"\n    \n    # Check if services are active\n    echo \"\\nüîÑ Service Active Status:\"\n    systemctl is-active story && echo \"‚úÖ Story: Active\" || echo \"‚ùå Story: Inactive\"\n    systemctl is-active story-geth && echo \"‚úÖ Story-Geth: Active\" || echo \"‚ùå Story-Geth: Inactive\"\n    \n    # Check API endpoints\n    echo \"\\nüåê API Endpoint Tests:\"\n    curl -s localhost:${STORY_PORT}657/status >/dev/null && echo \"‚úÖ Story RPC: Responsive\" || echo \"‚ùå Story RPC: Not responding\"\n    curl -s localhost:${STORY_PORT}545 -X POST -H \"Content-Type: application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' >/dev/null && echo \"‚úÖ Geth RPC: Responsive\" || echo \"‚ùå Geth RPC: Not responding\"\n    \n    echo \"============================\"\n}\n\n# Run validation\nvalidate_services\n```\n\n## üÜò Troubleshooting Services\n\n### Service Won't Start\n```bash\n# Check detailed status\nsudo systemctl status story.service -l\nsudo systemctl status story-geth.service -l\n\n# Check journal for errors\nsudo journalctl -u story --since \"1 hour ago\" --no-pager\nsudo journalctl -u story-geth --since \"1 hour ago\" --no-pager\n\n# Verify environment\nenv | grep DAEMON\necho \"Story Port: $STORY_PORT\"\n```\n\n### Cosmovisor Issues\n```bash\n# Check cosmovisor setup\nls -la $DAEMON_HOME/cosmovisor/current/bin/\ncosmovisor version\n\n# Test cosmovisor manually\nsudo -u $USER cosmovisor run version\n```\n\n### Permission Problems\n```bash\n# Fix service permissions\nsudo chown -R $USER:$USER $HOME/.story\nsudo chown $USER:$USER $HOME/go/bin/cosmovisor\nchmod +x $HOME/go/bin/cosmovisor\n```\n\n:::tip\n**Service Best Practices:**\n- Always start story-geth before story\n- Monitor logs during initial sync\n- Set up log rotation to manage disk space\n- Use systemctl enable to start services on boot\n- Regular service health checks\n:::"
        }
      ]
    },
    {
      "id": "snapshots",
      "title": "Snapshot Service",
      "icon": "‚ö°",
      "type": "section",
      "children": [
        {
          "id": "coinsspor-snapshots",
          "title": "Coinsspor Advanced Snapshots",
          "icon": "üì∏",
          "type": "page",
          "content": "# üì∏ Coinsspor Advanced Snapshot Service\n\n**Next-generation snapshot service with ZSTD compression and aria2c multi-connection downloads**\n\n- üîÑ **Updated**: Every 6 hours (00:00, 06:00, 12:00, 18:00 UTC)\n- üóúÔ∏è **Compression**: ZSTD format
